// Generated from .\ECMAScript.g4 by ANTLR 4.7.1
// jshint ignore: start
var antlr4 = require('antlr4/index');
var ECMAScriptListener = require('./ECMAScriptListener').ECMAScriptListener;
var grammarFileName = "ECMAScript.g4";

var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u0003k\u0281\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t",
    "\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007\u0004",
    "\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f\u0004",
    "\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010\u0004",
    "\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014\t",
    "\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017\u0004",
    "\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a\u0004\u001b\t",
    "\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e\t\u001e\u0004",
    "\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#\t#\u0004$\t$\u0004",
    "%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004*\t*\u0004+\t+\u0004",
    ",\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u00041\t1\u00042\t2\u0004",
    "3\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u00048\t8\u00049\t9\u0004",
    ":\t:\u0004;\t;\u0003\u0002\u0005\u0002x\n\u0002\u0003\u0002\u0003\u0002",
    "\u0003\u0003\u0006\u0003}\n\u0003\r\u0003\u000e\u0003~\u0003\u0004\u0003",
    "\u0004\u0005\u0004\u0083\n\u0004\u0003\u0005\u0003\u0005\u0005\u0005",
    "\u0087\n\u0005\u0003\u0006\u0003\u0006\u0005\u0006\u008b\n\u0006\u0003",
    "\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\b\u0003\b\u0003\b\u0003",
    "\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003",
    "\t\u0003\t\u0003\t\u0003\t\u0003\t\u0005\t\u00a2\n\t\u0003\n\u0003\n",
    "\u0005\n\u00a6\n\n\u0003\n\u0003\n\u0003\u000b\u0006\u000b\u00ab\n\u000b",
    "\r\u000b\u000e\u000b\u00ac\u0003\f\u0003\f\u0003\f\u0003\f\u0003\r\u0003",
    "\r\u0003\r\u0007\r\u00b6\n\r\f\r\u000e\r\u00b9\u000b\r\u0003\u000e\u0003",
    "\u000e\u0005\u000e\u00bd\n\u000e\u0003\u000f\u0003\u000f\u0003\u000f",
    "\u0003\u0010\u0003\u0010\u0003\u0011\u0003\u0011\u0003\u0012\u0003\u0012",
    "\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0005\u0012",
    "\u00cd\n\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0005\u0013\u00e0\n\u0013\u0003\u0013\u0003\u0013\u0005\u0013",
    "\u00e4\n\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u00e8\n\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0005\u0013\u00f2\n\u0013\u0003\u0013\u0003\u0013",
    "\u0005\u0013\u00f6\n\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u010c",
    "\n\u0013\u0003\u0014\u0003\u0014\u0003\u0014\u0005\u0014\u0111\n\u0014",
    "\u0003\u0014\u0003\u0014\u0003\u0015\u0003\u0015\u0003\u0015\u0005\u0015",
    "\u0118\n\u0015\u0003\u0015\u0003\u0015\u0003\u0016\u0003\u0016\u0003",
    "\u0016\u0005\u0016\u011f\n\u0016\u0003\u0016\u0003\u0016\u0003\u0017",
    "\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0018",
    "\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0019",
    "\u0003\u0019\u0005\u0019\u0131\n\u0019\u0003\u0019\u0003\u0019\u0005",
    "\u0019\u0135\n\u0019\u0005\u0019\u0137\n\u0019\u0003\u0019\u0003\u0019",
    "\u0003\u001a\u0006\u001a\u013c\n\u001a\r\u001a\u000e\u001a\u013d\u0003",
    "\u001b\u0003\u001b\u0003\u001b\u0003\u001b\u0005\u001b\u0144\n\u001b",
    "\u0003\u001c\u0003\u001c\u0003\u001c\u0005\u001c\u0149\n\u001c\u0003",
    "\u001d\u0003\u001d\u0003\u001d\u0003\u001d\u0003\u001e\u0003\u001e\u0003",
    "\u001e\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003\u001f\u0003",
    "\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0003",
    "\u001f\u0003\u001f\u0003\u001f\u0003\u001f\u0005\u001f\u0161\n\u001f",
    "\u0003 \u0003 \u0003 \u0003 \u0003 \u0003 \u0003!\u0003!\u0003!\u0003",
    "\"\u0003\"\u0003\"\u0003\"\u0005\"\u0170\n\"\u0003\"\u0003\"\u0003\"",
    "\u0003\"\u0003\"\u0003#\u0003#\u0003#\u0007#\u017a\n#\f#\u000e#\u017d",
    "\u000b#\u0003$\u0005$\u0180\n$\u0003%\u0003%\u0005%\u0184\n%\u0003%",
    "\u0005%\u0187\n%\u0003%\u0005%\u018a\n%\u0003%\u0003%\u0003&\u0005&",
    "\u018f\n&\u0003&\u0003&\u0003&\u0005&\u0194\n&\u0003&\u0007&\u0197\n",
    "&\f&\u000e&\u019a\u000b&\u0003\'\u0006\'\u019d\n\'\r\'\u000e\'\u019e",
    "\u0003(\u0003(\u0003(\u0003(\u0003(\u0005(\u01a6\n(\u0003(\u0003(\u0005",
    "(\u01aa\n(\u0003)\u0003)\u0003)\u0007)\u01af\n)\f)\u000e)\u01b2\u000b",
    ")\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003",
    "*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0003*\u0005",
    "*\u01c7\n*\u0003+\u0003+\u0003+\u0005+\u01cc\n+\u0003,\u0003,\u0003",
    "-\u0003-\u0005-\u01d2\n-\u0003-\u0003-\u0003.\u0003.\u0003.\u0007.\u01d9",
    "\n.\f.\u000e.\u01dc\u000b.\u0003/\u0003/\u0003/\u0007/\u01e1\n/\f/\u000e",
    "/\u01e4\u000b/\u00030\u00030\u00030\u00050\u01e9\n0\u00030\u00030\u0005",
    "0\u01ed\n0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0005",
    "0\u01f7\n0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00050\u0214",
    "\n0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u00030\u0003",
    "0\u00030\u00030\u00030\u00030\u00030\u00070\u0257\n0\f0\u000e0\u025a",
    "\u000b0\u00031\u00031\u00032\u00032\u00052\u0260\n2\u00033\u00033\u0003",
    "4\u00034\u00054\u0266\n4\u00035\u00035\u00035\u00055\u026b\n5\u0003",
    "6\u00036\u00037\u00037\u00038\u00038\u00038\u00038\u00039\u00039\u0003",
    "9\u00039\u0003:\u0003:\u0003:\u0003:\u0005:\u027d\n:\u0003;\u0003;\u0003",
    ";\u0002\u0003^<\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016",
    "\u0018\u001a\u001c\u001e \"$&(*,.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp",
    "rt\u0002\u000e\u0003\u0002fg\u0003\u0002\u0018\u001a\u0003\u0002\u0014",
    "\u0015\u0003\u0002\u001b\u001d\u0003\u0002\u001e!\u0003\u0002\"%\u0003",
    "\u0002+5\u0005\u0002\u0004\u000467gg\u0003\u00028:\u0003\u000267\u0003",
    "\u0002;S\u0003\u0002Ve\u0002\u02b4\u0002w\u0003\u0002\u0002\u0002\u0004",
    "|\u0003\u0002\u0002\u0002\u0006\u0082\u0003\u0002\u0002\u0002\b\u0086",
    "\u0003\u0002\u0002\u0002\n\u008a\u0003\u0002\u0002\u0002\f\u008c\u0003",
    "\u0002\u0002\u0002\u000e\u0090\u0003\u0002\u0002\u0002\u0010\u00a1\u0003",
    "\u0002\u0002\u0002\u0012\u00a3\u0003\u0002\u0002\u0002\u0014\u00aa\u0003",
    "\u0002\u0002\u0002\u0016\u00ae\u0003\u0002\u0002\u0002\u0018\u00b2\u0003",
    "\u0002\u0002\u0002\u001a\u00ba\u0003\u0002\u0002\u0002\u001c\u00be\u0003",
    "\u0002\u0002\u0002\u001e\u00c1\u0003\u0002\u0002\u0002 \u00c3\u0003",
    "\u0002\u0002\u0002\"\u00c5\u0003\u0002\u0002\u0002$\u010b\u0003\u0002",
    "\u0002\u0002&\u010d\u0003\u0002\u0002\u0002(\u0114\u0003\u0002\u0002",
    "\u0002*\u011b\u0003\u0002\u0002\u0002,\u0122\u0003\u0002\u0002\u0002",
    ".\u0128\u0003\u0002\u0002\u00020\u012e\u0003\u0002\u0002\u00022\u013b",
    "\u0003\u0002\u0002\u00024\u013f\u0003\u0002\u0002\u00026\u0145\u0003",
    "\u0002\u0002\u00028\u014a\u0003\u0002\u0002\u0002:\u014e\u0003\u0002",
    "\u0002\u0002<\u0160\u0003\u0002\u0002\u0002>\u0162\u0003\u0002\u0002",
    "\u0002@\u0168\u0003\u0002\u0002\u0002B\u016b\u0003\u0002\u0002\u0002",
    "D\u0176\u0003\u0002\u0002\u0002F\u017f\u0003\u0002\u0002\u0002H\u0181",
    "\u0003\u0002\u0002\u0002J\u018e\u0003\u0002\u0002\u0002L\u019c\u0003",
    "\u0002\u0002\u0002N\u01a9\u0003\u0002\u0002\u0002P\u01ab\u0003\u0002",
    "\u0002\u0002R\u01c6\u0003\u0002\u0002\u0002T\u01cb\u0003\u0002\u0002",
    "\u0002V\u01cd\u0003\u0002\u0002\u0002X\u01cf\u0003\u0002\u0002\u0002",
    "Z\u01d5\u0003\u0002\u0002\u0002\\\u01dd\u0003\u0002\u0002\u0002^\u0213",
    "\u0003\u0002\u0002\u0002`\u025b\u0003\u0002\u0002\u0002b\u025f\u0003",
    "\u0002\u0002\u0002d\u0261\u0003\u0002\u0002\u0002f\u0265\u0003\u0002",
    "\u0002\u0002h\u026a\u0003\u0002\u0002\u0002j\u026c\u0003\u0002\u0002",
    "\u0002l\u026e\u0003\u0002\u0002\u0002n\u0270\u0003\u0002\u0002\u0002",
    "p\u0274\u0003\u0002\u0002\u0002r\u027c\u0003\u0002\u0002\u0002t\u027e",
    "\u0003\u0002\u0002\u0002vx\u0005\u0004\u0003\u0002wv\u0003\u0002\u0002",
    "\u0002wx\u0003\u0002\u0002\u0002xy\u0003\u0002\u0002\u0002yz\u0007\u0002",
    "\u0002\u0003z\u0003\u0003\u0002\u0002\u0002{}\u0005\u0006\u0004\u0002",
    "|{\u0003\u0002\u0002\u0002}~\u0003\u0002\u0002\u0002~|\u0003\u0002\u0002",
    "\u0002~\u007f\u0003\u0002\u0002\u0002\u007f\u0005\u0003\u0002\u0002",
    "\u0002\u0080\u0083\u0005\b\u0005\u0002\u0081\u0083\u0005\n\u0006\u0002",
    "\u0082\u0080\u0003\u0002\u0002\u0002\u0082\u0081\u0003\u0002\u0002\u0002",
    "\u0083\u0007\u0003\u0002\u0002\u0002\u0084\u0087\u0005\u0010\t\u0002",
    "\u0085\u0087\u0005B\"\u0002\u0086\u0084\u0003\u0002\u0002\u0002\u0086",
    "\u0085\u0003\u0002\u0002\u0002\u0087\t\u0003\u0002\u0002\u0002\u0088",
    "\u008b\u0005\f\u0007\u0002\u0089\u008b\u0005\u000e\b\u0002\u008a\u0088",
    "\u0003\u0002\u0002\u0002\u008a\u0089\u0003\u0002\u0002\u0002\u008b\u000b",
    "\u0003\u0002\u0002\u0002\u008c\u008d\u0007T\u0002\u0002\u008d\u008e",
    "\u0007\u0003\u0002\u0002\u008e\u008f\t\u0002\u0002\u0002\u008f\r\u0003",
    "\u0002\u0002\u0002\u0090\u0091\u0007U\u0002\u0002\u0091\u0092\t\u0002",
    "\u0002\u0002\u0092\u000f\u0003\u0002\u0002\u0002\u0093\u00a2\u0005\u0012",
    "\n\u0002\u0094\u00a2\u0005\u0016\f\u0002\u0095\u00a2\u0005\u001e\u0010",
    "\u0002\u0096\u00a2\u0005 \u0011\u0002\u0097\u00a2\u0005\"\u0012\u0002",
    "\u0098\u00a2\u0005$\u0013\u0002\u0099\u00a2\u0005&\u0014\u0002\u009a",
    "\u00a2\u0005(\u0015\u0002\u009b\u00a2\u0005*\u0016\u0002\u009c\u00a2",
    "\u0005,\u0017\u0002\u009d\u00a2\u00058\u001d\u0002\u009e\u00a2\u0005",
    ".\u0018\u0002\u009f\u00a2\u0005:\u001e\u0002\u00a0\u00a2\u0005<\u001f",
    "\u0002\u00a1\u0093\u0003\u0002\u0002\u0002\u00a1\u0094\u0003\u0002\u0002",
    "\u0002\u00a1\u0095\u0003\u0002\u0002\u0002\u00a1\u0096\u0003\u0002\u0002",
    "\u0002\u00a1\u0097\u0003\u0002\u0002\u0002\u00a1\u0098\u0003\u0002\u0002",
    "\u0002\u00a1\u0099\u0003\u0002\u0002\u0002\u00a1\u009a\u0003\u0002\u0002",
    "\u0002\u00a1\u009b\u0003\u0002\u0002\u0002\u00a1\u009c\u0003\u0002\u0002",
    "\u0002\u00a1\u009d\u0003\u0002\u0002\u0002\u00a1\u009e\u0003\u0002\u0002",
    "\u0002\u00a1\u009f\u0003\u0002\u0002\u0002\u00a1\u00a0\u0003\u0002\u0002",
    "\u0002\u00a2\u0011\u0003\u0002\u0002\u0002\u00a3\u00a5\u0007\n\u0002",
    "\u0002\u00a4\u00a6\u0005\u0014\u000b\u0002\u00a5\u00a4\u0003\u0002\u0002",
    "\u0002\u00a5\u00a6\u0003\u0002\u0002\u0002\u00a6\u00a7\u0003\u0002\u0002",
    "\u0002\u00a7\u00a8\u0007\u000b\u0002\u0002\u00a8\u0013\u0003\u0002\u0002",
    "\u0002\u00a9\u00ab\u0005\u0010\t\u0002\u00aa\u00a9\u0003\u0002\u0002",
    "\u0002\u00ab\u00ac\u0003\u0002\u0002\u0002\u00ac\u00aa\u0003\u0002\u0002",
    "\u0002\u00ac\u00ad\u0003\u0002\u0002\u0002\u00ad\u0015\u0003\u0002\u0002",
    "\u0002\u00ae\u00af\u0007B\u0002\u0002\u00af\u00b0\u0005\u0018\r\u0002",
    "\u00b0\u00b1\u0005r:\u0002\u00b1\u0017\u0003\u0002\u0002\u0002\u00b2",
    "\u00b7\u0005\u001a\u000e\u0002\u00b3\u00b4\u0007\r\u0002\u0002\u00b4",
    "\u00b6\u0005\u001a\u000e\u0002\u00b5\u00b3\u0003\u0002\u0002\u0002\u00b6",
    "\u00b9\u0003\u0002\u0002\u0002\u00b7\u00b5\u0003\u0002\u0002\u0002\u00b7",
    "\u00b8\u0003\u0002\u0002\u0002\u00b8\u0019\u0003\u0002\u0002\u0002\u00b9",
    "\u00b7\u0003\u0002\u0002\u0002\u00ba\u00bc\u0007f\u0002\u0002\u00bb",
    "\u00bd\u0005\u001c\u000f\u0002\u00bc\u00bb\u0003\u0002\u0002\u0002\u00bc",
    "\u00bd\u0003\u0002\u0002\u0002\u00bd\u001b\u0003\u0002\u0002\u0002\u00be",
    "\u00bf\u0007\u000e\u0002\u0002\u00bf\u00c0\u0005^0\u0002\u00c0\u001d",
    "\u0003\u0002\u0002\u0002\u00c1\u00c2\u0007\f\u0002\u0002\u00c2\u001f",
    "\u0003\u0002\u0002\u0002\u00c3\u00c4\u0005\\/\u0002\u00c4!\u0003\u0002",
    "\u0002\u0002\u00c5\u00c6\u0007O\u0002\u0002\u00c6\u00c7\u0007\b\u0002",
    "\u0002\u00c7\u00c8\u0005\\/\u0002\u00c8\u00c9\u0007\t\u0002\u0002\u00c9",
    "\u00cc\u0005\u0010\t\u0002\u00ca\u00cb\u0007@\u0002\u0002\u00cb\u00cd",
    "\u0005\u0010\t\u0002\u00cc\u00ca\u0003\u0002\u0002\u0002\u00cc\u00cd",
    "\u0003\u0002\u0002\u0002\u00cd#\u0003\u0002\u0002\u0002\u00ce\u00cf",
    "\u0007<\u0002\u0002\u00cf\u00d0\u0005\u0010\t\u0002\u00d0\u00d1\u0007",
    "J\u0002\u0002\u00d1\u00d2\u0007\b\u0002\u0002\u00d2\u00d3\u0005\\/\u0002",
    "\u00d3\u00d4\u0007\t\u0002\u0002\u00d4\u00d5\u0005r:\u0002\u00d5\u010c",
    "\u0003\u0002\u0002\u0002\u00d6\u00d7\u0007J\u0002\u0002\u00d7\u00d8",
    "\u0007\b\u0002\u0002\u00d8\u00d9\u0005\\/\u0002\u00d9\u00da\u0007\t",
    "\u0002\u0002\u00da\u00db\u0005\u0010\t\u0002\u00db\u010c\u0003\u0002",
    "\u0002\u0002\u00dc\u00dd\u0007H\u0002\u0002\u00dd\u00df\u0007\b\u0002",
    "\u0002\u00de\u00e0\u0005\\/\u0002\u00df\u00de\u0003\u0002\u0002\u0002",
    "\u00df\u00e0\u0003\u0002\u0002\u0002\u00e0\u00e1\u0003\u0002\u0002\u0002",
    "\u00e1\u00e3\u0007\f\u0002\u0002\u00e2\u00e4\u0005\\/\u0002\u00e3\u00e2",
    "\u0003\u0002\u0002\u0002\u00e3\u00e4\u0003\u0002\u0002\u0002\u00e4\u00e5",
    "\u0003\u0002\u0002\u0002\u00e5\u00e7\u0007\f\u0002\u0002\u00e6\u00e8",
    "\u0005\\/\u0002\u00e7\u00e6\u0003\u0002\u0002\u0002\u00e7\u00e8\u0003",
    "\u0002\u0002\u0002\u00e8\u00e9\u0003\u0002\u0002\u0002\u00e9\u00ea\u0007",
    "\t\u0002\u0002\u00ea\u010c\u0005\u0010\t\u0002\u00eb\u00ec\u0007H\u0002",
    "\u0002\u00ec\u00ed\u0007\b\u0002\u0002\u00ed\u00ee\u0007B\u0002\u0002",
    "\u00ee\u00ef\u0005\u0018\r\u0002\u00ef\u00f1\u0007\f\u0002\u0002\u00f0",
    "\u00f2\u0005\\/\u0002\u00f1\u00f0\u0003\u0002\u0002\u0002\u00f1\u00f2",
    "\u0003\u0002\u0002\u0002\u00f2\u00f3\u0003\u0002\u0002\u0002\u00f3\u00f5",
    "\u0007\f\u0002\u0002\u00f4\u00f6\u0005\\/\u0002\u00f5\u00f4\u0003\u0002",
    "\u0002\u0002\u00f5\u00f6\u0003\u0002\u0002\u0002\u00f6\u00f7\u0003\u0002",
    "\u0002\u0002\u00f7\u00f8\u0007\t\u0002\u0002\u00f8\u00f9\u0005\u0010",
    "\t\u0002\u00f9\u010c\u0003\u0002\u0002\u0002\u00fa\u00fb\u0007H\u0002",
    "\u0002\u00fb\u00fc\u0007\b\u0002\u0002\u00fc\u00fd\u0005^0\u0002\u00fd",
    "\u00fe\u0007R\u0002\u0002\u00fe\u00ff\u0005\\/\u0002\u00ff\u0100\u0007",
    "\t\u0002\u0002\u0100\u0101\u0005\u0010\t\u0002\u0101\u010c\u0003\u0002",
    "\u0002\u0002\u0102\u0103\u0007H\u0002\u0002\u0103\u0104\u0007\b\u0002",
    "\u0002\u0104\u0105\u0007B\u0002\u0002\u0105\u0106\u0005\u001a\u000e",
    "\u0002\u0106\u0107\u0007R\u0002\u0002\u0107\u0108\u0005\\/\u0002\u0108",
    "\u0109\u0007\t\u0002\u0002\u0109\u010a\u0005\u0010\t\u0002\u010a\u010c",
    "\u0003\u0002\u0002\u0002\u010b\u00ce\u0003\u0002\u0002\u0002\u010b\u00d6",
    "\u0003\u0002\u0002\u0002\u010b\u00dc\u0003\u0002\u0002\u0002\u010b\u00eb",
    "\u0003\u0002\u0002\u0002\u010b\u00fa\u0003\u0002\u0002\u0002\u010b\u0102",
    "\u0003\u0002\u0002\u0002\u010c%\u0003\u0002\u0002\u0002\u010d\u0110",
    "\u0007G\u0002\u0002\u010e\u010f\u0006\u0014\u0002\u0002\u010f\u0111",
    "\u0007f\u0002\u0002\u0110\u010e\u0003\u0002\u0002\u0002\u0110\u0111",
    "\u0003\u0002\u0002\u0002\u0111\u0112\u0003\u0002\u0002\u0002\u0112\u0113",
    "\u0005r:\u0002\u0113\'\u0003\u0002\u0002\u0002\u0114\u0117\u0007;\u0002",
    "\u0002\u0115\u0116\u0006\u0015\u0003\u0002\u0116\u0118\u0007f\u0002",
    "\u0002\u0117\u0115\u0003\u0002\u0002\u0002\u0117\u0118\u0003\u0002\u0002",
    "\u0002\u0118\u0119\u0003\u0002\u0002\u0002\u0119\u011a\u0005r:\u0002",
    "\u011a)\u0003\u0002\u0002\u0002\u011b\u011e\u0007E\u0002\u0002\u011c",
    "\u011d\u0006\u0016\u0004\u0002\u011d\u011f\u0005\\/\u0002\u011e\u011c",
    "\u0003\u0002\u0002\u0002\u011e\u011f\u0003\u0002\u0002\u0002\u011f\u0120",
    "\u0003\u0002\u0002\u0002\u0120\u0121\u0005r:\u0002\u0121+\u0003\u0002",
    "\u0002\u0002\u0122\u0123\u0007M\u0002\u0002\u0123\u0124\u0007\b\u0002",
    "\u0002\u0124\u0125\u0005\\/\u0002\u0125\u0126\u0007\t\u0002\u0002\u0126",
    "\u0127\u0005\u0010\t\u0002\u0127-\u0003\u0002\u0002\u0002\u0128\u0129",
    "\u0007I\u0002\u0002\u0129\u012a\u0007\b\u0002\u0002\u012a\u012b\u0005",
    "\\/\u0002\u012b\u012c\u0007\t\u0002\u0002\u012c\u012d\u00050\u0019\u0002",
    "\u012d/\u0003\u0002\u0002\u0002\u012e\u0130\u0007\n\u0002\u0002\u012f",
    "\u0131\u00052\u001a\u0002\u0130\u012f\u0003\u0002\u0002\u0002\u0130",
    "\u0131\u0003\u0002\u0002\u0002\u0131\u0136\u0003\u0002\u0002\u0002\u0132",
    "\u0134\u00056\u001c\u0002\u0133\u0135\u00052\u001a\u0002\u0134\u0133",
    "\u0003\u0002\u0002\u0002\u0134\u0135\u0003\u0002\u0002\u0002\u0135\u0137",
    "\u0003\u0002\u0002\u0002\u0136\u0132\u0003\u0002\u0002\u0002\u0136\u0137",
    "\u0003\u0002\u0002\u0002\u0137\u0138\u0003\u0002\u0002\u0002\u0138\u0139",
    "\u0007\u000b\u0002\u0002\u01391\u0003\u0002\u0002\u0002\u013a\u013c",
    "\u00054\u001b\u0002\u013b\u013a\u0003\u0002\u0002\u0002\u013c\u013d",
    "\u0003\u0002\u0002\u0002\u013d\u013b\u0003\u0002\u0002\u0002\u013d\u013e",
    "\u0003\u0002\u0002\u0002\u013e3\u0003\u0002\u0002\u0002\u013f\u0140",
    "\u0007?\u0002\u0002\u0140\u0141\u0005\\/\u0002\u0141\u0143\u0007\u0010",
    "\u0002\u0002\u0142\u0144\u0005\u0014\u000b\u0002\u0143\u0142\u0003\u0002",
    "\u0002\u0002\u0143\u0144\u0003\u0002\u0002\u0002\u01445\u0003\u0002",
    "\u0002\u0002\u0145\u0146\u0007N\u0002\u0002\u0146\u0148\u0007\u0010",
    "\u0002\u0002\u0147\u0149\u0005\u0014\u000b\u0002\u0148\u0147\u0003\u0002",
    "\u0002\u0002\u0148\u0149\u0003\u0002\u0002\u0002\u01497\u0003\u0002",
    "\u0002\u0002\u014a\u014b\u0007f\u0002\u0002\u014b\u014c\u0007\u0010",
    "\u0002\u0002\u014c\u014d\u0005\u0010\t\u0002\u014d9\u0003\u0002\u0002",
    "\u0002\u014e\u014f\u0007P\u0002\u0002\u014f\u0150\u0006\u001e\u0005",
    "\u0002\u0150\u0151\u0005\\/\u0002\u0151\u0152\u0005r:\u0002\u0152;\u0003",
    "\u0002\u0002\u0002\u0153\u0154\u0007S\u0002\u0002\u0154\u0155\u0005",
    "\u0012\n\u0002\u0155\u0156\u0005> \u0002\u0156\u0161\u0003\u0002\u0002",
    "\u0002\u0157\u0158\u0007S\u0002\u0002\u0158\u0159\u0005\u0012\n\u0002",
    "\u0159\u015a\u0005@!\u0002\u015a\u0161\u0003\u0002\u0002\u0002\u015b",
    "\u015c\u0007S\u0002\u0002\u015c\u015d\u0005\u0012\n\u0002\u015d\u015e",
    "\u0005> \u0002\u015e\u015f\u0005@!\u0002\u015f\u0161\u0003\u0002\u0002",
    "\u0002\u0160\u0153\u0003\u0002\u0002\u0002\u0160\u0157\u0003\u0002\u0002",
    "\u0002\u0160\u015b\u0003\u0002\u0002\u0002\u0161=\u0003\u0002\u0002",
    "\u0002\u0162\u0163\u0007C\u0002\u0002\u0163\u0164\u0007\b\u0002\u0002",
    "\u0164\u0165\u0007f\u0002\u0002\u0165\u0166\u0007\t\u0002\u0002\u0166",
    "\u0167\u0005\u0012\n\u0002\u0167?\u0003\u0002\u0002\u0002\u0168\u0169",
    "\u0007D\u0002\u0002\u0169\u016a\u0005\u0012\n\u0002\u016aA\u0003\u0002",
    "\u0002\u0002\u016b\u016c\u0007K\u0002\u0002\u016c\u016d\u0007f\u0002",
    "\u0002\u016d\u016f\u0007\b\u0002\u0002\u016e\u0170\u0005D#\u0002\u016f",
    "\u016e\u0003\u0002\u0002\u0002\u016f\u0170\u0003\u0002\u0002\u0002\u0170",
    "\u0171\u0003\u0002\u0002\u0002\u0171\u0172\u0007\t\u0002\u0002\u0172",
    "\u0173\u0007\n\u0002\u0002\u0173\u0174\u0005F$\u0002\u0174\u0175\u0007",
    "\u000b\u0002\u0002\u0175C\u0003\u0002\u0002\u0002\u0176\u017b\u0007",
    "f\u0002\u0002\u0177\u0178\u0007\r\u0002\u0002\u0178\u017a\u0007f\u0002",
    "\u0002\u0179\u0177\u0003\u0002\u0002\u0002\u017a\u017d\u0003\u0002\u0002",
    "\u0002\u017b\u0179\u0003\u0002\u0002\u0002\u017b\u017c\u0003\u0002\u0002",
    "\u0002\u017cE\u0003\u0002\u0002\u0002\u017d\u017b\u0003\u0002\u0002",
    "\u0002\u017e\u0180\u0005\u0004\u0003\u0002\u017f\u017e\u0003\u0002\u0002",
    "\u0002\u017f\u0180\u0003\u0002\u0002\u0002\u0180G\u0003\u0002\u0002",
    "\u0002\u0181\u0183\u0007\u0006\u0002\u0002\u0182\u0184\u0005J&\u0002",
    "\u0183\u0182\u0003\u0002\u0002\u0002\u0183\u0184\u0003\u0002\u0002\u0002",
    "\u0184\u0186\u0003\u0002\u0002\u0002\u0185\u0187\u0007\r\u0002\u0002",
    "\u0186\u0185\u0003\u0002\u0002\u0002\u0186\u0187\u0003\u0002\u0002\u0002",
    "\u0187\u0189\u0003\u0002\u0002\u0002\u0188\u018a\u0005L\'\u0002\u0189",
    "\u0188\u0003\u0002\u0002\u0002\u0189\u018a\u0003\u0002\u0002\u0002\u018a",
    "\u018b\u0003\u0002\u0002\u0002\u018b\u018c\u0007\u0007\u0002\u0002\u018c",
    "I\u0003\u0002\u0002\u0002\u018d\u018f\u0005L\'\u0002\u018e\u018d\u0003",
    "\u0002\u0002\u0002\u018e\u018f\u0003\u0002\u0002\u0002\u018f\u0190\u0003",
    "\u0002\u0002\u0002\u0190\u0198\u0005^0\u0002\u0191\u0193\u0007\r\u0002",
    "\u0002\u0192\u0194\u0005L\'\u0002\u0193\u0192\u0003\u0002\u0002\u0002",
    "\u0193\u0194\u0003\u0002\u0002\u0002\u0194\u0195\u0003\u0002\u0002\u0002",
    "\u0195\u0197\u0005^0\u0002\u0196\u0191\u0003\u0002\u0002\u0002\u0197",
    "\u019a\u0003\u0002\u0002\u0002\u0198\u0196\u0003\u0002\u0002\u0002\u0198",
    "\u0199\u0003\u0002\u0002\u0002\u0199K\u0003\u0002\u0002\u0002\u019a",
    "\u0198\u0003\u0002\u0002\u0002\u019b\u019d\u0007\r\u0002\u0002\u019c",
    "\u019b\u0003\u0002\u0002\u0002\u019d\u019e\u0003\u0002\u0002\u0002\u019e",
    "\u019c\u0003\u0002\u0002\u0002\u019e\u019f\u0003\u0002\u0002\u0002\u019f",
    "M\u0003\u0002\u0002\u0002\u01a0\u01a1\u0007\n\u0002\u0002\u01a1\u01aa",
    "\u0007\u000b\u0002\u0002\u01a2\u01a3\u0007\n\u0002\u0002\u01a3\u01a5",
    "\u0005P)\u0002\u01a4\u01a6\u0007\r\u0002\u0002\u01a5\u01a4\u0003\u0002",
    "\u0002\u0002\u01a5\u01a6\u0003\u0002\u0002\u0002\u01a6\u01a7\u0003\u0002",
    "\u0002\u0002\u01a7\u01a8\u0007\u000b\u0002\u0002\u01a8\u01aa\u0003\u0002",
    "\u0002\u0002\u01a9\u01a0\u0003\u0002\u0002\u0002\u01a9\u01a2\u0003\u0002",
    "\u0002\u0002\u01aaO\u0003\u0002\u0002\u0002\u01ab\u01b0\u0005R*\u0002",
    "\u01ac\u01ad\u0007\r\u0002\u0002\u01ad\u01af\u0005R*\u0002\u01ae\u01ac",
    "\u0003\u0002\u0002\u0002\u01af\u01b2\u0003\u0002\u0002\u0002\u01b0\u01ae",
    "\u0003\u0002\u0002\u0002\u01b0\u01b1\u0003\u0002\u0002\u0002\u01b1Q",
    "\u0003\u0002\u0002\u0002\u01b2\u01b0\u0003\u0002\u0002\u0002\u01b3\u01b4",
    "\u0005T+\u0002\u01b4\u01b5\u0007\u0010\u0002\u0002\u01b5\u01b6\u0005",
    "^0\u0002\u01b6\u01c7\u0003\u0002\u0002\u0002\u01b7\u01b8\u0005n8\u0002",
    "\u01b8\u01b9\u0007\b\u0002\u0002\u01b9\u01ba\u0007\t\u0002\u0002\u01ba",
    "\u01bb\u0007\n\u0002\u0002\u01bb\u01bc\u0005F$\u0002\u01bc\u01bd\u0007",
    "\u000b\u0002\u0002\u01bd\u01c7\u0003\u0002\u0002\u0002\u01be\u01bf\u0005",
    "p9\u0002\u01bf\u01c0\u0007\b\u0002\u0002\u01c0\u01c1\u0005V,\u0002\u01c1",
    "\u01c2\u0007\t\u0002\u0002\u01c2\u01c3\u0007\n\u0002\u0002\u01c3\u01c4",
    "\u0005F$\u0002\u01c4\u01c5\u0007\u000b\u0002\u0002\u01c5\u01c7\u0003",
    "\u0002\u0002\u0002\u01c6\u01b3\u0003\u0002\u0002\u0002\u01c6\u01b7\u0003",
    "\u0002\u0002\u0002\u01c6\u01be\u0003\u0002\u0002\u0002\u01c7S\u0003",
    "\u0002\u0002\u0002\u01c8\u01cc\u0005f4\u0002\u01c9\u01cc\u0007g\u0002",
    "\u0002\u01ca\u01cc\u0005d3\u0002\u01cb\u01c8\u0003\u0002\u0002\u0002",
    "\u01cb\u01c9\u0003\u0002\u0002\u0002\u01cb\u01ca\u0003\u0002\u0002\u0002",
    "\u01ccU\u0003\u0002\u0002\u0002\u01cd\u01ce\u0007f\u0002\u0002\u01ce",
    "W\u0003\u0002\u0002\u0002\u01cf\u01d1\u0007\b\u0002\u0002\u01d0\u01d2",
    "\u0005Z.\u0002\u01d1\u01d0\u0003\u0002\u0002\u0002\u01d1\u01d2\u0003",
    "\u0002\u0002\u0002\u01d2\u01d3\u0003\u0002\u0002\u0002\u01d3\u01d4\u0007",
    "\t\u0002\u0002\u01d4Y\u0003\u0002\u0002\u0002\u01d5\u01da\u0005^0\u0002",
    "\u01d6\u01d7\u0007\r\u0002\u0002\u01d7\u01d9\u0005^0\u0002\u01d8\u01d6",
    "\u0003\u0002\u0002\u0002\u01d9\u01dc\u0003\u0002\u0002\u0002\u01da\u01d8",
    "\u0003\u0002\u0002\u0002\u01da\u01db\u0003\u0002\u0002\u0002\u01db[",
    "\u0003\u0002\u0002\u0002\u01dc\u01da\u0003\u0002\u0002\u0002\u01dd\u01e2",
    "\u0005^0\u0002\u01de\u01df\u0007\r\u0002\u0002\u01df\u01e1\u0005^0\u0002",
    "\u01e0\u01de\u0003\u0002\u0002\u0002\u01e1\u01e4\u0003\u0002\u0002\u0002",
    "\u01e2\u01e0\u0003\u0002\u0002\u0002\u01e2\u01e3\u0003\u0002\u0002\u0002",
    "\u01e3]\u0003\u0002\u0002\u0002\u01e4\u01e2\u0003\u0002\u0002\u0002",
    "\u01e5\u01e6\b0\u0001\u0002\u01e6\u01e8\u0007K\u0002\u0002\u01e7\u01e9",
    "\u0007f\u0002\u0002\u01e8\u01e7\u0003\u0002\u0002\u0002\u01e8\u01e9",
    "\u0003\u0002\u0002\u0002\u01e9\u01ea\u0003\u0002\u0002\u0002\u01ea\u01ec",
    "\u0007\b\u0002\u0002\u01eb\u01ed\u0005D#\u0002\u01ec\u01eb\u0003\u0002",
    "\u0002\u0002\u01ec\u01ed\u0003\u0002\u0002\u0002\u01ed\u01ee\u0003\u0002",
    "\u0002\u0002\u01ee\u01ef\u0007\t\u0002\u0002\u01ef\u01f0\u0007\n\u0002",
    "\u0002\u01f0\u01f1\u0005F$\u0002\u01f1\u01f2\u0007\u000b\u0002\u0002",
    "\u01f2\u0214\u0003\u0002\u0002\u0002\u01f3\u01f4\u0007A\u0002\u0002",
    "\u01f4\u01f6\u0005^0\u0002\u01f5\u01f7\u0005X-\u0002\u01f6\u01f5\u0003",
    "\u0002\u0002\u0002\u01f6\u01f7\u0003\u0002\u0002\u0002\u01f7\u0214\u0003",
    "\u0002\u0002\u0002\u01f8\u01f9\u0007Q\u0002\u0002\u01f9\u0214\u0005",
    "^0 \u01fa\u01fb\u0007F\u0002\u0002\u01fb\u0214\u0005^0\u001f\u01fc\u01fd",
    "\u0007>\u0002\u0002\u01fd\u0214\u0005^0\u001e\u01fe\u01ff\u0007\u0012",
    "\u0002\u0002\u01ff\u0214\u0005^0\u001d\u0200\u0201\u0007\u0013\u0002",
    "\u0002\u0201\u0214\u0005^0\u001c\u0202\u0203\u0007\u0014\u0002\u0002",
    "\u0203\u0214\u0005^0\u001b\u0204\u0205\u0007\u0015\u0002\u0002\u0205",
    "\u0214\u0005^0\u001a\u0206\u0207\u0007\u0016\u0002\u0002\u0207\u0214",
    "\u0005^0\u0019\u0208\u0209\u0007\u0017\u0002\u0002\u0209\u0214\u0005",
    "^0\u0018\u020a\u0214\u0007L\u0002\u0002\u020b\u0214\u0007f\u0002\u0002",
    "\u020c\u0214\u0005b2\u0002\u020d\u0214\u0005H%\u0002\u020e\u0214\u0005",
    "N(\u0002\u020f\u0210\u0007\b\u0002\u0002\u0210\u0211\u0005\\/\u0002",
    "\u0211\u0212\u0007\t\u0002\u0002\u0212\u0214\u0003\u0002\u0002\u0002",
    "\u0213\u01e5\u0003\u0002\u0002\u0002\u0213\u01f3\u0003\u0002\u0002\u0002",
    "\u0213\u01f8\u0003\u0002\u0002\u0002\u0213\u01fa\u0003\u0002\u0002\u0002",
    "\u0213\u01fc\u0003\u0002\u0002\u0002\u0213\u01fe\u0003\u0002\u0002\u0002",
    "\u0213\u0200\u0003\u0002\u0002\u0002\u0213\u0202\u0003\u0002\u0002\u0002",
    "\u0213\u0204\u0003\u0002\u0002\u0002\u0213\u0206\u0003\u0002\u0002\u0002",
    "\u0213\u0208\u0003\u0002\u0002\u0002\u0213\u020a\u0003\u0002\u0002\u0002",
    "\u0213\u020b\u0003\u0002\u0002\u0002\u0213\u020c\u0003\u0002\u0002\u0002",
    "\u0213\u020d\u0003\u0002\u0002\u0002\u0213\u020e\u0003\u0002\u0002\u0002",
    "\u0213\u020f\u0003\u0002\u0002\u0002\u0214\u0258\u0003\u0002\u0002\u0002",
    "\u0215\u0216\f\u0017\u0002\u0002\u0216\u0217\t\u0003\u0002\u0002\u0217",
    "\u0257\u0005^0\u0018\u0218\u0219\f\u0016\u0002\u0002\u0219\u021a\t\u0004",
    "\u0002\u0002\u021a\u0257\u0005^0\u0017\u021b\u021c\f\u0015\u0002\u0002",
    "\u021c\u021d\t\u0005\u0002\u0002\u021d\u0257\u0005^0\u0016\u021e\u021f",
    "\f\u0014\u0002\u0002\u021f\u0220\t\u0006\u0002\u0002\u0220\u0257\u0005",
    "^0\u0015\u0221\u0222\f\u0013\u0002\u0002\u0222\u0223\u0007=\u0002\u0002",
    "\u0223\u0257\u0005^0\u0014\u0224\u0225\f\u0012\u0002\u0002\u0225\u0226",
    "\u0007R\u0002\u0002\u0226\u0257\u0005^0\u0013\u0227\u0228\f\u0011\u0002",
    "\u0002\u0228\u0229\t\u0007\u0002\u0002\u0229\u0257\u0005^0\u0012\u022a",
    "\u022b\f\u0010\u0002\u0002\u022b\u022c\u0007&\u0002\u0002\u022c\u0257",
    "\u0005^0\u0011\u022d\u022e\f\u000f\u0002\u0002\u022e\u022f\u0007\'\u0002",
    "\u0002\u022f\u0257\u0005^0\u0010\u0230\u0231\f\u000e\u0002\u0002\u0231",
    "\u0232\u0007(\u0002\u0002\u0232\u0257\u0005^0\u000f\u0233\u0234\f\r",
    "\u0002\u0002\u0234\u0235\u0007)\u0002\u0002\u0235\u0257\u0005^0\u000e",
    "\u0236\u0237\f\f\u0002\u0002\u0237\u0238\u0007*\u0002\u0002\u0238\u0257",
    "\u0005^0\r\u0239\u023a\f\u000b\u0002\u0002\u023a\u023b\u0007\u000f\u0002",
    "\u0002\u023b\u023c\u0005^0\u0002\u023c\u023d\u0007\u0010\u0002\u0002",
    "\u023d\u023e\u0005^0\f\u023e\u0257\u0003\u0002\u0002\u0002\u023f\u0240",
    "\f&\u0002\u0002\u0240\u0241\u0007\u0006\u0002\u0002\u0241\u0242\u0005",
    "\\/\u0002\u0242\u0243\u0007\u0007\u0002\u0002\u0243\u0257\u0003\u0002",
    "\u0002\u0002\u0244\u0245\f%\u0002\u0002\u0245\u0246\u0007\u0011\u0002",
    "\u0002\u0246\u0257\u0005f4\u0002\u0247\u0248\f$\u0002\u0002\u0248\u0257",
    "\u0005X-\u0002\u0249\u024a\f\"\u0002\u0002\u024a\u024b\u00060\u0017",
    "\u0002\u024b\u0257\u0007\u0012\u0002\u0002\u024c\u024d\f!\u0002\u0002",
    "\u024d\u024e\u00060\u0019\u0002\u024e\u0257\u0007\u0013\u0002\u0002",
    "\u024f\u0250\f\n\u0002\u0002\u0250\u0251\u0007\u000e\u0002\u0002\u0251",
    "\u0257\u0005\\/\u0002\u0252\u0253\f\t\u0002\u0002\u0253\u0254\u0005",
    "`1\u0002\u0254\u0255\u0005\\/\u0002\u0255\u0257\u0003\u0002\u0002\u0002",
    "\u0256\u0215\u0003\u0002\u0002\u0002\u0256\u0218\u0003\u0002\u0002\u0002",
    "\u0256\u021b\u0003\u0002\u0002\u0002\u0256\u021e\u0003\u0002\u0002\u0002",
    "\u0256\u0221\u0003\u0002\u0002\u0002\u0256\u0224\u0003\u0002\u0002\u0002",
    "\u0256\u0227\u0003\u0002\u0002\u0002\u0256\u022a\u0003\u0002\u0002\u0002",
    "\u0256\u022d\u0003\u0002\u0002\u0002\u0256\u0230\u0003\u0002\u0002\u0002",
    "\u0256\u0233\u0003\u0002\u0002\u0002\u0256\u0236\u0003\u0002\u0002\u0002",
    "\u0256\u0239\u0003\u0002\u0002\u0002\u0256\u023f\u0003\u0002\u0002\u0002",
    "\u0256\u0244\u0003\u0002\u0002\u0002\u0256\u0247\u0003\u0002\u0002\u0002",
    "\u0256\u0249\u0003\u0002\u0002\u0002\u0256\u024c\u0003\u0002\u0002\u0002",
    "\u0256\u024f\u0003\u0002\u0002\u0002\u0256\u0252\u0003\u0002\u0002\u0002",
    "\u0257\u025a\u0003\u0002\u0002\u0002\u0258\u0256\u0003\u0002\u0002\u0002",
    "\u0258\u0259\u0003\u0002\u0002\u0002\u0259_\u0003\u0002\u0002\u0002",
    "\u025a\u0258\u0003\u0002\u0002\u0002\u025b\u025c\t\b\u0002\u0002\u025c",
    "a\u0003\u0002\u0002\u0002\u025d\u0260\t\t\u0002\u0002\u025e\u0260\u0005",
    "d3\u0002\u025f\u025d\u0003\u0002\u0002\u0002\u025f\u025e\u0003\u0002",
    "\u0002\u0002\u0260c\u0003\u0002\u0002\u0002\u0261\u0262\t\n\u0002\u0002",
    "\u0262e\u0003\u0002\u0002\u0002\u0263\u0266\u0007f\u0002\u0002\u0264",
    "\u0266\u0005h5\u0002\u0265\u0263\u0003\u0002\u0002\u0002\u0265\u0264",
    "\u0003\u0002\u0002\u0002\u0266g\u0003\u0002\u0002\u0002\u0267\u026b",
    "\u0005j6\u0002\u0268\u026b\u0005l7\u0002\u0269\u026b\t\u000b\u0002\u0002",
    "\u026a\u0267\u0003\u0002\u0002\u0002\u026a\u0268\u0003\u0002\u0002\u0002",
    "\u026a\u0269\u0003\u0002\u0002\u0002\u026bi\u0003\u0002\u0002\u0002",
    "\u026c\u026d\t\f\u0002\u0002\u026dk\u0003\u0002\u0002\u0002\u026e\u026f",
    "\t\r\u0002\u0002\u026fm\u0003\u0002\u0002\u0002\u0270\u0271\u00068\u001c",
    "\u0002\u0271\u0272\u0007f\u0002\u0002\u0272\u0273\u0005T+\u0002\u0273",
    "o\u0003\u0002\u0002\u0002\u0274\u0275\u00069\u001d\u0002\u0275\u0276",
    "\u0007f\u0002\u0002\u0276\u0277\u0005T+\u0002\u0277q\u0003\u0002\u0002",
    "\u0002\u0278\u027d\u0007\f\u0002\u0002\u0279\u027d\u0007\u0002\u0002",
    "\u0003\u027a\u027d\u0006:\u001e\u0002\u027b\u027d\u0006:\u001f\u0002",
    "\u027c\u0278\u0003\u0002\u0002\u0002\u027c\u0279\u0003\u0002\u0002\u0002",
    "\u027c\u027a\u0003\u0002\u0002\u0002\u027c\u027b\u0003\u0002\u0002\u0002",
    "\u027ds\u0003\u0002\u0002\u0002\u027e\u027f\u0007\u0002\u0002\u0003",
    "\u027fu\u0003\u0002\u0002\u00029w~\u0082\u0086\u008a\u00a1\u00a5\u00ac",
    "\u00b7\u00bc\u00cc\u00df\u00e3\u00e7\u00f1\u00f5\u010b\u0110\u0117\u011e",
    "\u0130\u0134\u0136\u013d\u0143\u0148\u0160\u016f\u017b\u017f\u0183\u0186",
    "\u0189\u018e\u0193\u0198\u019e\u01a5\u01a9\u01b0\u01c6\u01cb\u01d1\u01da",
    "\u01e2\u01e8\u01ec\u01f6\u0213\u0256\u0258\u025f\u0265\u026a\u027c"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, "':)'", null, null, "'['", "']'", "'('", "')'", 
                     "'{'", "'}'", "';'", "','", "'='", "'?'", "':'", "'.'", 
                     "'++'", "'--'", "'+'", "'-'", "'~'", "'!'", "'*'", 
                     "'/'", "'%'", "'>>'", "'<<'", "'>>>'", "'<'", "'>'", 
                     "'<='", "'>='", "'=='", "'!='", "'==='", "'!=='", "'&'", 
                     "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='", "'%='", 
                     "'+='", "'-='", "'<<='", "'>>='", "'>>>='", "'&='", 
                     "'^='", "'|='", "'null'", null, null, null, null, "'break'", 
                     "'do'", "'instanceof '", "'typeof '", "'case'", "'else'", 
                     "'new '", "'var '", "'catch'", "'finally'", "'return '", 
                     "'void'", "'continue'", "'for'", "'switch'", "'while'", 
                     "'function'", "'this'", "'with '", "'default '", "'if'", 
                     "'throw '", "'delete '", "' in '", "'try'", "'owl_get'", 
                     "'owl_post'", "'class '", "'enum '", "'extends '", 
                     "'super'", "'const '", "'export '", "'import '" ];

var symbolicNames = [ null, null, "RegularExpressionLiteral", "LineTerminator", 
                      "OpenBracket", "CloseBracket", "OpenParen", "CloseParen", 
                      "OpenBrace", "CloseBrace", "SemiColon", "Comma", "Assign", 
                      "QuestionMark", "Colon", "Dot", "PlusPlus", "MinusMinus", 
                      "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide", 
                      "Modulus", "RightShiftArithmetic", "LeftShiftArithmetic", 
                      "RightShiftLogical", "LessThan", "MoreThan", "LessThanEquals", 
                      "GreaterThanEquals", "Equals", "NotEquals", "IdentityEquals", 
                      "IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", 
                      "And", "Or", "MultiplyAssign", "DivideAssign", "ModulusAssign", 
                      "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign", 
                      "RightShiftArithmeticAssign", "RightShiftLogicalAssign", 
                      "BitAndAssign", "BitXorAssign", "BitOrAssign", "NullLiteral", 
                      "BooleanLiteral", "DecimalLiteral", "HexIntegerLiteral", 
                      "OctalIntegerLiteral", "Break", "Do", "Instanceof", 
                      "Typeof", "Case", "Else", "New", "Var", "Catch", "Finally", 
                      "Return", "Void", "Continue", "For", "Switch", "While", 
                      "Function", "This", "With", "Default", "If", "Throw", 
                      "Delete", "In", "Try", "OwlGet", "OwlPost", "Class", 
                      "Enum", "Extends", "Super", "Const", "Export", "Import", 
                      "Implements", "Let", "Private", "Public", "Interface", 
                      "Package", "Protected", "Static", "Yield", "Identifier", 
                      "StringLiteral", "WhiteSpaces", "MultiLineComment", 
                      "SingleLineComment", "UnexpectedCharacter" ];

var ruleNames =  [ "program", "sourceElements", "element", "sourceElement", 
                   "owlElement", "owlGetStatement", "owlPostStatement", 
                   "statement", "block", "statementList", "variableStatement", 
                   "variableDeclarationList", "variableDeclaration", "initialiser", 
                   "emptyStatement", "expressionStatement", "ifStatement", 
                   "iterationStatement", "continueStatement", "breakStatement", 
                   "returnStatement", "withStatement", "switchStatement", 
                   "caseBlock", "caseClauses", "caseClause", "defaultClause", 
                   "labelledStatement", "throwStatement", "tryStatement", 
                   "catchProduction", "finallyProduction", "functionDeclaration", 
                   "formalParameterList", "functionBody", "arrayLiteral", 
                   "elementList", "elision", "objectLiteral", "propertyNameAndValueList", 
                   "propertyAssignment", "propertyName", "propertySetParameterList", 
                   "arguments", "argumentList", "expressionSequence", "singleExpression", 
                   "assignmentOperator", "literal", "numericLiteral", "identifierName", 
                   "reservedWord", "keyword", "futureReservedWord", "getter", 
                   "setter", "eos", "eof" ];

function ECMAScriptParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;

	/**
	 * Returns true if, on the current index of the parser's token stream,
	 * a token of the given type exists on the HIDDEN channel.
	 * @param type {Number} The type of the token on the HIDDEN channel to check.
	 * @returns {Boolean}
	 */
	ECMAScriptParser.prototype.here = function(type) {
	    var possibleIndexEosToken = antlr4.Parser.prototype.getCurrentToken.call(this).tokenIndex - 1;
	    var ahead = this._input.get(possibleIndexEosToken);
	    return (ahead.channel == antlr4.Lexer.HIDDEN) && (ahead.type == type);
	};

	/**
	 * Returns true if, on the current index of the parser's
	 * token stream, a token exists on the HIDDEN channel which
	 * either is a line terminator, or is a multi line comment that
	 * contains a line terminator.
	 * @returns {Boolean}
	 */
	ECMAScriptParser.prototype.lineTerminatorAhead = function() {
	    var possibleIndexEosToken = antlr4.Parser.prototype.getCurrentToken.call(this).tokenIndex - 1;
	    var ahead = this._input.get(possibleIndexEosToken);

	    if (ahead.channel != antlr4.Lexer.HIDDEN)
	        return false;

	    var text = ahead.text;
	    var type = ahead.type;

	    return (type == ECMAScriptParser.MultiLineComment && text.indexOf("\r") !== -1 || text.indexOf("\n") !== -1) ||
	            (type == ECMAScriptParser.LineTerminator);
	};

    return this;
}

ECMAScriptParser.prototype = Object.create(antlr4.Parser.prototype);
ECMAScriptParser.prototype.constructor = ECMAScriptParser;

Object.defineProperty(ECMAScriptParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

ECMAScriptParser.EOF = antlr4.Token.EOF;
ECMAScriptParser.T__0 = 1;
ECMAScriptParser.RegularExpressionLiteral = 2;
ECMAScriptParser.LineTerminator = 3;
ECMAScriptParser.OpenBracket = 4;
ECMAScriptParser.CloseBracket = 5;
ECMAScriptParser.OpenParen = 6;
ECMAScriptParser.CloseParen = 7;
ECMAScriptParser.OpenBrace = 8;
ECMAScriptParser.CloseBrace = 9;
ECMAScriptParser.SemiColon = 10;
ECMAScriptParser.Comma = 11;
ECMAScriptParser.Assign = 12;
ECMAScriptParser.QuestionMark = 13;
ECMAScriptParser.Colon = 14;
ECMAScriptParser.Dot = 15;
ECMAScriptParser.PlusPlus = 16;
ECMAScriptParser.MinusMinus = 17;
ECMAScriptParser.Plus = 18;
ECMAScriptParser.Minus = 19;
ECMAScriptParser.BitNot = 20;
ECMAScriptParser.Not = 21;
ECMAScriptParser.Multiply = 22;
ECMAScriptParser.Divide = 23;
ECMAScriptParser.Modulus = 24;
ECMAScriptParser.RightShiftArithmetic = 25;
ECMAScriptParser.LeftShiftArithmetic = 26;
ECMAScriptParser.RightShiftLogical = 27;
ECMAScriptParser.LessThan = 28;
ECMAScriptParser.MoreThan = 29;
ECMAScriptParser.LessThanEquals = 30;
ECMAScriptParser.GreaterThanEquals = 31;
ECMAScriptParser.Equals = 32;
ECMAScriptParser.NotEquals = 33;
ECMAScriptParser.IdentityEquals = 34;
ECMAScriptParser.IdentityNotEquals = 35;
ECMAScriptParser.BitAnd = 36;
ECMAScriptParser.BitXOr = 37;
ECMAScriptParser.BitOr = 38;
ECMAScriptParser.And = 39;
ECMAScriptParser.Or = 40;
ECMAScriptParser.MultiplyAssign = 41;
ECMAScriptParser.DivideAssign = 42;
ECMAScriptParser.ModulusAssign = 43;
ECMAScriptParser.PlusAssign = 44;
ECMAScriptParser.MinusAssign = 45;
ECMAScriptParser.LeftShiftArithmeticAssign = 46;
ECMAScriptParser.RightShiftArithmeticAssign = 47;
ECMAScriptParser.RightShiftLogicalAssign = 48;
ECMAScriptParser.BitAndAssign = 49;
ECMAScriptParser.BitXorAssign = 50;
ECMAScriptParser.BitOrAssign = 51;
ECMAScriptParser.NullLiteral = 52;
ECMAScriptParser.BooleanLiteral = 53;
ECMAScriptParser.DecimalLiteral = 54;
ECMAScriptParser.HexIntegerLiteral = 55;
ECMAScriptParser.OctalIntegerLiteral = 56;
ECMAScriptParser.Break = 57;
ECMAScriptParser.Do = 58;
ECMAScriptParser.Instanceof = 59;
ECMAScriptParser.Typeof = 60;
ECMAScriptParser.Case = 61;
ECMAScriptParser.Else = 62;
ECMAScriptParser.New = 63;
ECMAScriptParser.Var = 64;
ECMAScriptParser.Catch = 65;
ECMAScriptParser.Finally = 66;
ECMAScriptParser.Return = 67;
ECMAScriptParser.Void = 68;
ECMAScriptParser.Continue = 69;
ECMAScriptParser.For = 70;
ECMAScriptParser.Switch = 71;
ECMAScriptParser.While = 72;
ECMAScriptParser.Function = 73;
ECMAScriptParser.This = 74;
ECMAScriptParser.With = 75;
ECMAScriptParser.Default = 76;
ECMAScriptParser.If = 77;
ECMAScriptParser.Throw = 78;
ECMAScriptParser.Delete = 79;
ECMAScriptParser.In = 80;
ECMAScriptParser.Try = 81;
ECMAScriptParser.OwlGet = 82;
ECMAScriptParser.OwlPost = 83;
ECMAScriptParser.Class = 84;
ECMAScriptParser.Enum = 85;
ECMAScriptParser.Extends = 86;
ECMAScriptParser.Super = 87;
ECMAScriptParser.Const = 88;
ECMAScriptParser.Export = 89;
ECMAScriptParser.Import = 90;
ECMAScriptParser.Implements = 91;
ECMAScriptParser.Let = 92;
ECMAScriptParser.Private = 93;
ECMAScriptParser.Public = 94;
ECMAScriptParser.Interface = 95;
ECMAScriptParser.Package = 96;
ECMAScriptParser.Protected = 97;
ECMAScriptParser.Static = 98;
ECMAScriptParser.Yield = 99;
ECMAScriptParser.Identifier = 100;
ECMAScriptParser.StringLiteral = 101;
ECMAScriptParser.WhiteSpaces = 102;
ECMAScriptParser.MultiLineComment = 103;
ECMAScriptParser.SingleLineComment = 104;
ECMAScriptParser.UnexpectedCharacter = 105;

ECMAScriptParser.RULE_program = 0;
ECMAScriptParser.RULE_sourceElements = 1;
ECMAScriptParser.RULE_element = 2;
ECMAScriptParser.RULE_sourceElement = 3;
ECMAScriptParser.RULE_owlElement = 4;
ECMAScriptParser.RULE_owlGetStatement = 5;
ECMAScriptParser.RULE_owlPostStatement = 6;
ECMAScriptParser.RULE_statement = 7;
ECMAScriptParser.RULE_block = 8;
ECMAScriptParser.RULE_statementList = 9;
ECMAScriptParser.RULE_variableStatement = 10;
ECMAScriptParser.RULE_variableDeclarationList = 11;
ECMAScriptParser.RULE_variableDeclaration = 12;
ECMAScriptParser.RULE_initialiser = 13;
ECMAScriptParser.RULE_emptyStatement = 14;
ECMAScriptParser.RULE_expressionStatement = 15;
ECMAScriptParser.RULE_ifStatement = 16;
ECMAScriptParser.RULE_iterationStatement = 17;
ECMAScriptParser.RULE_continueStatement = 18;
ECMAScriptParser.RULE_breakStatement = 19;
ECMAScriptParser.RULE_returnStatement = 20;
ECMAScriptParser.RULE_withStatement = 21;
ECMAScriptParser.RULE_switchStatement = 22;
ECMAScriptParser.RULE_caseBlock = 23;
ECMAScriptParser.RULE_caseClauses = 24;
ECMAScriptParser.RULE_caseClause = 25;
ECMAScriptParser.RULE_defaultClause = 26;
ECMAScriptParser.RULE_labelledStatement = 27;
ECMAScriptParser.RULE_throwStatement = 28;
ECMAScriptParser.RULE_tryStatement = 29;
ECMAScriptParser.RULE_catchProduction = 30;
ECMAScriptParser.RULE_finallyProduction = 31;
ECMAScriptParser.RULE_functionDeclaration = 32;
ECMAScriptParser.RULE_formalParameterList = 33;
ECMAScriptParser.RULE_functionBody = 34;
ECMAScriptParser.RULE_arrayLiteral = 35;
ECMAScriptParser.RULE_elementList = 36;
ECMAScriptParser.RULE_elision = 37;
ECMAScriptParser.RULE_objectLiteral = 38;
ECMAScriptParser.RULE_propertyNameAndValueList = 39;
ECMAScriptParser.RULE_propertyAssignment = 40;
ECMAScriptParser.RULE_propertyName = 41;
ECMAScriptParser.RULE_propertySetParameterList = 42;
ECMAScriptParser.RULE_arguments = 43;
ECMAScriptParser.RULE_argumentList = 44;
ECMAScriptParser.RULE_expressionSequence = 45;
ECMAScriptParser.RULE_singleExpression = 46;
ECMAScriptParser.RULE_assignmentOperator = 47;
ECMAScriptParser.RULE_literal = 48;
ECMAScriptParser.RULE_numericLiteral = 49;
ECMAScriptParser.RULE_identifierName = 50;
ECMAScriptParser.RULE_reservedWord = 51;
ECMAScriptParser.RULE_keyword = 52;
ECMAScriptParser.RULE_futureReservedWord = 53;
ECMAScriptParser.RULE_getter = 54;
ECMAScriptParser.RULE_setter = 55;
ECMAScriptParser.RULE_eos = 56;
ECMAScriptParser.RULE_eof = 57;

function ProgramContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_program;
    return this;
}

ProgramContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ProgramContext.prototype.constructor = ProgramContext;

ProgramContext.prototype.EOF = function() {
    return this.getToken(ECMAScriptParser.EOF, 0);
};

ProgramContext.prototype.sourceElements = function() {
    return this.getTypedRuleContext(SourceElementsContext,0);
};

ProgramContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterProgram(this);
	}
};

ProgramContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitProgram(this);
	}
};




ECMAScriptParser.ProgramContext = ProgramContext;

ECMAScriptParser.prototype.program = function() {

    var localctx = new ProgramContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, ECMAScriptParser.RULE_program);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 117;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)) | (1 << (ECMAScriptParser.OwlGet - 52)) | (1 << (ECMAScriptParser.OwlPost - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
            this.state = 116;
            this.sourceElements();
        }

        this.state = 119;
        this.match(ECMAScriptParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SourceElementsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_sourceElements;
    return this;
}

SourceElementsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SourceElementsContext.prototype.constructor = SourceElementsContext;

SourceElementsContext.prototype.element = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ElementContext);
    } else {
        return this.getTypedRuleContext(ElementContext,i);
    }
};

SourceElementsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterSourceElements(this);
	}
};

SourceElementsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitSourceElements(this);
	}
};




ECMAScriptParser.SourceElementsContext = SourceElementsContext;

ECMAScriptParser.prototype.sourceElements = function() {

    var localctx = new SourceElementsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, ECMAScriptParser.RULE_sourceElements);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 122; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 121;
            this.element();
            this.state = 124; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)) | (1 << (ECMAScriptParser.OwlGet - 52)) | (1 << (ECMAScriptParser.OwlPost - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_element;
    return this;
}

ElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElementContext.prototype.constructor = ElementContext;

ElementContext.prototype.sourceElement = function() {
    return this.getTypedRuleContext(SourceElementContext,0);
};

ElementContext.prototype.owlElement = function() {
    return this.getTypedRuleContext(OwlElementContext,0);
};

ElementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterElement(this);
	}
};

ElementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitElement(this);
	}
};




ECMAScriptParser.ElementContext = ElementContext;

ECMAScriptParser.prototype.element = function() {

    var localctx = new ElementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, ECMAScriptParser.RULE_element);
    try {
        this.state = 128;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.RegularExpressionLiteral:
        case ECMAScriptParser.OpenBracket:
        case ECMAScriptParser.OpenParen:
        case ECMAScriptParser.OpenBrace:
        case ECMAScriptParser.SemiColon:
        case ECMAScriptParser.PlusPlus:
        case ECMAScriptParser.MinusMinus:
        case ECMAScriptParser.Plus:
        case ECMAScriptParser.Minus:
        case ECMAScriptParser.BitNot:
        case ECMAScriptParser.Not:
        case ECMAScriptParser.NullLiteral:
        case ECMAScriptParser.BooleanLiteral:
        case ECMAScriptParser.DecimalLiteral:
        case ECMAScriptParser.HexIntegerLiteral:
        case ECMAScriptParser.OctalIntegerLiteral:
        case ECMAScriptParser.Break:
        case ECMAScriptParser.Do:
        case ECMAScriptParser.Typeof:
        case ECMAScriptParser.New:
        case ECMAScriptParser.Var:
        case ECMAScriptParser.Return:
        case ECMAScriptParser.Void:
        case ECMAScriptParser.Continue:
        case ECMAScriptParser.For:
        case ECMAScriptParser.Switch:
        case ECMAScriptParser.While:
        case ECMAScriptParser.Function:
        case ECMAScriptParser.This:
        case ECMAScriptParser.With:
        case ECMAScriptParser.If:
        case ECMAScriptParser.Throw:
        case ECMAScriptParser.Delete:
        case ECMAScriptParser.Try:
        case ECMAScriptParser.Identifier:
        case ECMAScriptParser.StringLiteral:
            this.enterOuterAlt(localctx, 1);
            this.state = 126;
            this.sourceElement();
            break;
        case ECMAScriptParser.OwlGet:
        case ECMAScriptParser.OwlPost:
            this.enterOuterAlt(localctx, 2);
            this.state = 127;
            this.owlElement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SourceElementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_sourceElement;
    return this;
}

SourceElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SourceElementContext.prototype.constructor = SourceElementContext;

SourceElementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

SourceElementContext.prototype.functionDeclaration = function() {
    return this.getTypedRuleContext(FunctionDeclarationContext,0);
};

SourceElementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterSourceElement(this);
	}
};

SourceElementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitSourceElement(this);
	}
};




ECMAScriptParser.SourceElementContext = SourceElementContext;

ECMAScriptParser.prototype.sourceElement = function() {

    var localctx = new SourceElementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, ECMAScriptParser.RULE_sourceElement);
    try {
        this.state = 132;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,3,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 130;
            this.statement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 131;
            this.functionDeclaration();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function OwlElementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_owlElement;
    return this;
}

OwlElementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OwlElementContext.prototype.constructor = OwlElementContext;

OwlElementContext.prototype.owlGetStatement = function() {
    return this.getTypedRuleContext(OwlGetStatementContext,0);
};

OwlElementContext.prototype.owlPostStatement = function() {
    return this.getTypedRuleContext(OwlPostStatementContext,0);
};

OwlElementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterOwlElement(this);
	}
};

OwlElementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitOwlElement(this);
	}
};




ECMAScriptParser.OwlElementContext = OwlElementContext;

ECMAScriptParser.prototype.owlElement = function() {

    var localctx = new OwlElementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, ECMAScriptParser.RULE_owlElement);
    try {
        this.state = 136;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.OwlGet:
            this.enterOuterAlt(localctx, 1);
            this.state = 134;
            this.owlGetStatement();
            break;
        case ECMAScriptParser.OwlPost:
            this.enterOuterAlt(localctx, 2);
            this.state = 135;
            this.owlPostStatement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function OwlGetStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_owlGetStatement;
    return this;
}

OwlGetStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OwlGetStatementContext.prototype.constructor = OwlGetStatementContext;

OwlGetStatementContext.prototype.OwlGet = function() {
    return this.getToken(ECMAScriptParser.OwlGet, 0);
};

OwlGetStatementContext.prototype.StringLiteral = function() {
    return this.getToken(ECMAScriptParser.StringLiteral, 0);
};

OwlGetStatementContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

OwlGetStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterOwlGetStatement(this);
	}
};

OwlGetStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitOwlGetStatement(this);
	}
};




ECMAScriptParser.OwlGetStatementContext = OwlGetStatementContext;

ECMAScriptParser.prototype.owlGetStatement = function() {

    var localctx = new OwlGetStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, ECMAScriptParser.RULE_owlGetStatement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 138;
        this.match(ECMAScriptParser.OwlGet);
        this.state = 139;
        this.match(ECMAScriptParser.T__0);
        this.state = 140;
        _la = this._input.LA(1);
        if(!(_la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function OwlPostStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_owlPostStatement;
    return this;
}

OwlPostStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
OwlPostStatementContext.prototype.constructor = OwlPostStatementContext;

OwlPostStatementContext.prototype.OwlPost = function() {
    return this.getToken(ECMAScriptParser.OwlPost, 0);
};

OwlPostStatementContext.prototype.StringLiteral = function() {
    return this.getToken(ECMAScriptParser.StringLiteral, 0);
};

OwlPostStatementContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

OwlPostStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterOwlPostStatement(this);
	}
};

OwlPostStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitOwlPostStatement(this);
	}
};




ECMAScriptParser.OwlPostStatementContext = OwlPostStatementContext;

ECMAScriptParser.prototype.owlPostStatement = function() {

    var localctx = new OwlPostStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, ECMAScriptParser.RULE_owlPostStatement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 142;
        this.match(ECMAScriptParser.OwlPost);
        this.state = 143;
        _la = this._input.LA(1);
        if(!(_la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral)) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_statement;
    return this;
}

StatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementContext.prototype.constructor = StatementContext;

StatementContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

StatementContext.prototype.variableStatement = function() {
    return this.getTypedRuleContext(VariableStatementContext,0);
};

StatementContext.prototype.emptyStatement = function() {
    return this.getTypedRuleContext(EmptyStatementContext,0);
};

StatementContext.prototype.expressionStatement = function() {
    return this.getTypedRuleContext(ExpressionStatementContext,0);
};

StatementContext.prototype.ifStatement = function() {
    return this.getTypedRuleContext(IfStatementContext,0);
};

StatementContext.prototype.iterationStatement = function() {
    return this.getTypedRuleContext(IterationStatementContext,0);
};

StatementContext.prototype.continueStatement = function() {
    return this.getTypedRuleContext(ContinueStatementContext,0);
};

StatementContext.prototype.breakStatement = function() {
    return this.getTypedRuleContext(BreakStatementContext,0);
};

StatementContext.prototype.returnStatement = function() {
    return this.getTypedRuleContext(ReturnStatementContext,0);
};

StatementContext.prototype.withStatement = function() {
    return this.getTypedRuleContext(WithStatementContext,0);
};

StatementContext.prototype.labelledStatement = function() {
    return this.getTypedRuleContext(LabelledStatementContext,0);
};

StatementContext.prototype.switchStatement = function() {
    return this.getTypedRuleContext(SwitchStatementContext,0);
};

StatementContext.prototype.throwStatement = function() {
    return this.getTypedRuleContext(ThrowStatementContext,0);
};

StatementContext.prototype.tryStatement = function() {
    return this.getTypedRuleContext(TryStatementContext,0);
};

StatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterStatement(this);
	}
};

StatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitStatement(this);
	}
};




ECMAScriptParser.StatementContext = StatementContext;

ECMAScriptParser.prototype.statement = function() {

    var localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, ECMAScriptParser.RULE_statement);
    try {
        this.state = 159;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,5,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 145;
            this.block();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 146;
            this.variableStatement();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 147;
            this.emptyStatement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 148;
            this.expressionStatement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 149;
            this.ifStatement();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 150;
            this.iterationStatement();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 151;
            this.continueStatement();
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 152;
            this.breakStatement();
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 153;
            this.returnStatement();
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 154;
            this.withStatement();
            break;

        case 11:
            this.enterOuterAlt(localctx, 11);
            this.state = 155;
            this.labelledStatement();
            break;

        case 12:
            this.enterOuterAlt(localctx, 12);
            this.state = 156;
            this.switchStatement();
            break;

        case 13:
            this.enterOuterAlt(localctx, 13);
            this.state = 157;
            this.throwStatement();
            break;

        case 14:
            this.enterOuterAlt(localctx, 14);
            this.state = 158;
            this.tryStatement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_block;
    return this;
}

BlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockContext.prototype.constructor = BlockContext;

BlockContext.prototype.statementList = function() {
    return this.getTypedRuleContext(StatementListContext,0);
};

BlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBlock(this);
	}
};

BlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBlock(this);
	}
};




ECMAScriptParser.BlockContext = BlockContext;

ECMAScriptParser.prototype.block = function() {

    var localctx = new BlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, ECMAScriptParser.RULE_block);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 161;
        this.match(ECMAScriptParser.OpenBrace);
        this.state = 163;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
            this.state = 162;
            this.statementList();
        }

        this.state = 165;
        this.match(ECMAScriptParser.CloseBrace);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_statementList;
    return this;
}

StatementListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementListContext.prototype.constructor = StatementListContext;

StatementListContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

StatementListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterStatementList(this);
	}
};

StatementListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitStatementList(this);
	}
};




ECMAScriptParser.StatementListContext = StatementListContext;

ECMAScriptParser.prototype.statementList = function() {

    var localctx = new StatementListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, ECMAScriptParser.RULE_statementList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 168; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 167;
            this.statement();
            this.state = 170; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_variableStatement;
    return this;
}

VariableStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableStatementContext.prototype.constructor = VariableStatementContext;

VariableStatementContext.prototype.Var = function() {
    return this.getToken(ECMAScriptParser.Var, 0);
};

VariableStatementContext.prototype.variableDeclarationList = function() {
    return this.getTypedRuleContext(VariableDeclarationListContext,0);
};

VariableStatementContext.prototype.eos = function() {
    return this.getTypedRuleContext(EosContext,0);
};

VariableStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterVariableStatement(this);
	}
};

VariableStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitVariableStatement(this);
	}
};




ECMAScriptParser.VariableStatementContext = VariableStatementContext;

ECMAScriptParser.prototype.variableStatement = function() {

    var localctx = new VariableStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, ECMAScriptParser.RULE_variableStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 172;
        this.match(ECMAScriptParser.Var);
        this.state = 173;
        this.variableDeclarationList();
        this.state = 174;
        this.eos();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableDeclarationListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_variableDeclarationList;
    return this;
}

VariableDeclarationListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableDeclarationListContext.prototype.constructor = VariableDeclarationListContext;

VariableDeclarationListContext.prototype.variableDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableDeclarationContext);
    } else {
        return this.getTypedRuleContext(VariableDeclarationContext,i);
    }
};

VariableDeclarationListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterVariableDeclarationList(this);
	}
};

VariableDeclarationListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitVariableDeclarationList(this);
	}
};




ECMAScriptParser.VariableDeclarationListContext = VariableDeclarationListContext;

ECMAScriptParser.prototype.variableDeclarationList = function() {

    var localctx = new VariableDeclarationListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, ECMAScriptParser.RULE_variableDeclarationList);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 176;
        this.variableDeclaration();
        this.state = 181;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,8,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 177;
                this.match(ECMAScriptParser.Comma);
                this.state = 178;
                this.variableDeclaration(); 
            }
            this.state = 183;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,8,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_variableDeclaration;
    return this;
}

VariableDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableDeclarationContext.prototype.constructor = VariableDeclarationContext;

VariableDeclarationContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

VariableDeclarationContext.prototype.initialiser = function() {
    return this.getTypedRuleContext(InitialiserContext,0);
};

VariableDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterVariableDeclaration(this);
	}
};

VariableDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitVariableDeclaration(this);
	}
};




ECMAScriptParser.VariableDeclarationContext = VariableDeclarationContext;

ECMAScriptParser.prototype.variableDeclaration = function() {

    var localctx = new VariableDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, ECMAScriptParser.RULE_variableDeclaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 184;
        this.match(ECMAScriptParser.Identifier);
        this.state = 186;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);
        if(la_===1) {
            this.state = 185;
            this.initialiser();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitialiserContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_initialiser;
    return this;
}

InitialiserContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitialiserContext.prototype.constructor = InitialiserContext;

InitialiserContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

InitialiserContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterInitialiser(this);
	}
};

InitialiserContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitInitialiser(this);
	}
};




ECMAScriptParser.InitialiserContext = InitialiserContext;

ECMAScriptParser.prototype.initialiser = function() {

    var localctx = new InitialiserContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, ECMAScriptParser.RULE_initialiser);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 188;
        this.match(ECMAScriptParser.Assign);
        this.state = 189;
        this.singleExpression(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EmptyStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_emptyStatement;
    return this;
}

EmptyStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EmptyStatementContext.prototype.constructor = EmptyStatementContext;

EmptyStatementContext.prototype.SemiColon = function() {
    return this.getToken(ECMAScriptParser.SemiColon, 0);
};

EmptyStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterEmptyStatement(this);
	}
};

EmptyStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitEmptyStatement(this);
	}
};




ECMAScriptParser.EmptyStatementContext = EmptyStatementContext;

ECMAScriptParser.prototype.emptyStatement = function() {

    var localctx = new EmptyStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, ECMAScriptParser.RULE_emptyStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 191;
        this.match(ECMAScriptParser.SemiColon);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_expressionStatement;
    return this;
}

ExpressionStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionStatementContext.prototype.constructor = ExpressionStatementContext;

ExpressionStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

ExpressionStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterExpressionStatement(this);
	}
};

ExpressionStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitExpressionStatement(this);
	}
};




ECMAScriptParser.ExpressionStatementContext = ExpressionStatementContext;

ECMAScriptParser.prototype.expressionStatement = function() {

    var localctx = new ExpressionStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, ECMAScriptParser.RULE_expressionStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 193;
        this.expressionSequence();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IfStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_ifStatement;
    return this;
}

IfStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IfStatementContext.prototype.constructor = IfStatementContext;

IfStatementContext.prototype.If = function() {
    return this.getToken(ECMAScriptParser.If, 0);
};

IfStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

IfStatementContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

IfStatementContext.prototype.Else = function() {
    return this.getToken(ECMAScriptParser.Else, 0);
};

IfStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterIfStatement(this);
	}
};

IfStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitIfStatement(this);
	}
};




ECMAScriptParser.IfStatementContext = IfStatementContext;

ECMAScriptParser.prototype.ifStatement = function() {

    var localctx = new IfStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, ECMAScriptParser.RULE_ifStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 195;
        this.match(ECMAScriptParser.If);
        this.state = 196;
        this.match(ECMAScriptParser.OpenParen);
        this.state = 197;
        this.expressionSequence();
        this.state = 198;
        this.match(ECMAScriptParser.CloseParen);
        this.state = 199;
        this.statement();
        this.state = 202;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,10,this._ctx);
        if(la_===1) {
            this.state = 200;
            this.match(ECMAScriptParser.Else);
            this.state = 201;
            this.statement();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IterationStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_iterationStatement;
    return this;
}

IterationStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IterationStatementContext.prototype.constructor = IterationStatementContext;


 
IterationStatementContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function DoStatementContext(parser, ctx) {
	IterationStatementContext.call(this, parser);
    IterationStatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DoStatementContext.prototype = Object.create(IterationStatementContext.prototype);
DoStatementContext.prototype.constructor = DoStatementContext;

ECMAScriptParser.DoStatementContext = DoStatementContext;

DoStatementContext.prototype.Do = function() {
    return this.getToken(ECMAScriptParser.Do, 0);
};

DoStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

DoStatementContext.prototype.While = function() {
    return this.getToken(ECMAScriptParser.While, 0);
};

DoStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

DoStatementContext.prototype.eos = function() {
    return this.getTypedRuleContext(EosContext,0);
};
DoStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterDoStatement(this);
	}
};

DoStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitDoStatement(this);
	}
};


function ForVarStatementContext(parser, ctx) {
	IterationStatementContext.call(this, parser);
    IterationStatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ForVarStatementContext.prototype = Object.create(IterationStatementContext.prototype);
ForVarStatementContext.prototype.constructor = ForVarStatementContext;

ECMAScriptParser.ForVarStatementContext = ForVarStatementContext;

ForVarStatementContext.prototype.For = function() {
    return this.getToken(ECMAScriptParser.For, 0);
};

ForVarStatementContext.prototype.Var = function() {
    return this.getToken(ECMAScriptParser.Var, 0);
};

ForVarStatementContext.prototype.variableDeclarationList = function() {
    return this.getTypedRuleContext(VariableDeclarationListContext,0);
};

ForVarStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

ForVarStatementContext.prototype.expressionSequence = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionSequenceContext);
    } else {
        return this.getTypedRuleContext(ExpressionSequenceContext,i);
    }
};
ForVarStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterForVarStatement(this);
	}
};

ForVarStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitForVarStatement(this);
	}
};


function ForVarInStatementContext(parser, ctx) {
	IterationStatementContext.call(this, parser);
    IterationStatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ForVarInStatementContext.prototype = Object.create(IterationStatementContext.prototype);
ForVarInStatementContext.prototype.constructor = ForVarInStatementContext;

ECMAScriptParser.ForVarInStatementContext = ForVarInStatementContext;

ForVarInStatementContext.prototype.For = function() {
    return this.getToken(ECMAScriptParser.For, 0);
};

ForVarInStatementContext.prototype.Var = function() {
    return this.getToken(ECMAScriptParser.Var, 0);
};

ForVarInStatementContext.prototype.variableDeclaration = function() {
    return this.getTypedRuleContext(VariableDeclarationContext,0);
};

ForVarInStatementContext.prototype.In = function() {
    return this.getToken(ECMAScriptParser.In, 0);
};

ForVarInStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

ForVarInStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};
ForVarInStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterForVarInStatement(this);
	}
};

ForVarInStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitForVarInStatement(this);
	}
};


function WhileStatementContext(parser, ctx) {
	IterationStatementContext.call(this, parser);
    IterationStatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

WhileStatementContext.prototype = Object.create(IterationStatementContext.prototype);
WhileStatementContext.prototype.constructor = WhileStatementContext;

ECMAScriptParser.WhileStatementContext = WhileStatementContext;

WhileStatementContext.prototype.While = function() {
    return this.getToken(ECMAScriptParser.While, 0);
};

WhileStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

WhileStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};
WhileStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterWhileStatement(this);
	}
};

WhileStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitWhileStatement(this);
	}
};


function ForStatementContext(parser, ctx) {
	IterationStatementContext.call(this, parser);
    IterationStatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ForStatementContext.prototype = Object.create(IterationStatementContext.prototype);
ForStatementContext.prototype.constructor = ForStatementContext;

ECMAScriptParser.ForStatementContext = ForStatementContext;

ForStatementContext.prototype.For = function() {
    return this.getToken(ECMAScriptParser.For, 0);
};

ForStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

ForStatementContext.prototype.expressionSequence = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionSequenceContext);
    } else {
        return this.getTypedRuleContext(ExpressionSequenceContext,i);
    }
};
ForStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterForStatement(this);
	}
};

ForStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitForStatement(this);
	}
};


function ForInStatementContext(parser, ctx) {
	IterationStatementContext.call(this, parser);
    IterationStatementContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ForInStatementContext.prototype = Object.create(IterationStatementContext.prototype);
ForInStatementContext.prototype.constructor = ForInStatementContext;

ECMAScriptParser.ForInStatementContext = ForInStatementContext;

ForInStatementContext.prototype.For = function() {
    return this.getToken(ECMAScriptParser.For, 0);
};

ForInStatementContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

ForInStatementContext.prototype.In = function() {
    return this.getToken(ECMAScriptParser.In, 0);
};

ForInStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

ForInStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};
ForInStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterForInStatement(this);
	}
};

ForInStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitForInStatement(this);
	}
};



ECMAScriptParser.IterationStatementContext = IterationStatementContext;

ECMAScriptParser.prototype.iterationStatement = function() {

    var localctx = new IterationStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, ECMAScriptParser.RULE_iterationStatement);
    var _la = 0; // Token type
    try {
        this.state = 265;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,16,this._ctx);
        switch(la_) {
        case 1:
            localctx = new DoStatementContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 204;
            this.match(ECMAScriptParser.Do);
            this.state = 205;
            this.statement();
            this.state = 206;
            this.match(ECMAScriptParser.While);
            this.state = 207;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 208;
            this.expressionSequence();
            this.state = 209;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 210;
            this.eos();
            break;

        case 2:
            localctx = new WhileStatementContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 212;
            this.match(ECMAScriptParser.While);
            this.state = 213;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 214;
            this.expressionSequence();
            this.state = 215;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 216;
            this.statement();
            break;

        case 3:
            localctx = new ForStatementContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 218;
            this.match(ECMAScriptParser.For);
            this.state = 219;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 221;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.Delete - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
                this.state = 220;
                this.expressionSequence();
            }

            this.state = 223;
            this.match(ECMAScriptParser.SemiColon);
            this.state = 225;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.Delete - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
                this.state = 224;
                this.expressionSequence();
            }

            this.state = 227;
            this.match(ECMAScriptParser.SemiColon);
            this.state = 229;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.Delete - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
                this.state = 228;
                this.expressionSequence();
            }

            this.state = 231;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 232;
            this.statement();
            break;

        case 4:
            localctx = new ForVarStatementContext(this, localctx);
            this.enterOuterAlt(localctx, 4);
            this.state = 233;
            this.match(ECMAScriptParser.For);
            this.state = 234;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 235;
            this.match(ECMAScriptParser.Var);
            this.state = 236;
            this.variableDeclarationList();
            this.state = 237;
            this.match(ECMAScriptParser.SemiColon);
            this.state = 239;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.Delete - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
                this.state = 238;
                this.expressionSequence();
            }

            this.state = 241;
            this.match(ECMAScriptParser.SemiColon);
            this.state = 243;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.Delete - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
                this.state = 242;
                this.expressionSequence();
            }

            this.state = 245;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 246;
            this.statement();
            break;

        case 5:
            localctx = new ForInStatementContext(this, localctx);
            this.enterOuterAlt(localctx, 5);
            this.state = 248;
            this.match(ECMAScriptParser.For);
            this.state = 249;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 250;
            this.singleExpression(0);
            this.state = 251;
            this.match(ECMAScriptParser.In);
            this.state = 252;
            this.expressionSequence();
            this.state = 253;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 254;
            this.statement();
            break;

        case 6:
            localctx = new ForVarInStatementContext(this, localctx);
            this.enterOuterAlt(localctx, 6);
            this.state = 256;
            this.match(ECMAScriptParser.For);
            this.state = 257;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 258;
            this.match(ECMAScriptParser.Var);
            this.state = 259;
            this.variableDeclaration();
            this.state = 260;
            this.match(ECMAScriptParser.In);
            this.state = 261;
            this.expressionSequence();
            this.state = 262;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 263;
            this.statement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ContinueStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_continueStatement;
    return this;
}

ContinueStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ContinueStatementContext.prototype.constructor = ContinueStatementContext;

ContinueStatementContext.prototype.Continue = function() {
    return this.getToken(ECMAScriptParser.Continue, 0);
};

ContinueStatementContext.prototype.eos = function() {
    return this.getTypedRuleContext(EosContext,0);
};

ContinueStatementContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

ContinueStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterContinueStatement(this);
	}
};

ContinueStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitContinueStatement(this);
	}
};




ECMAScriptParser.ContinueStatementContext = ContinueStatementContext;

ECMAScriptParser.prototype.continueStatement = function() {

    var localctx = new ContinueStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, ECMAScriptParser.RULE_continueStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 267;
        this.match(ECMAScriptParser.Continue);
        this.state = 270;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,17,this._ctx);
        if(la_===1) {
            this.state = 268;
            if (!( !this.here(ECMAScriptParser.LineTerminator))) {
                throw new antlr4.error.FailedPredicateException(this, "!this.here(ECMAScriptParser.LineTerminator)");
            }
            this.state = 269;
            this.match(ECMAScriptParser.Identifier);

        }
        this.state = 272;
        this.eos();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BreakStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_breakStatement;
    return this;
}

BreakStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BreakStatementContext.prototype.constructor = BreakStatementContext;

BreakStatementContext.prototype.Break = function() {
    return this.getToken(ECMAScriptParser.Break, 0);
};

BreakStatementContext.prototype.eos = function() {
    return this.getTypedRuleContext(EosContext,0);
};

BreakStatementContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

BreakStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBreakStatement(this);
	}
};

BreakStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBreakStatement(this);
	}
};




ECMAScriptParser.BreakStatementContext = BreakStatementContext;

ECMAScriptParser.prototype.breakStatement = function() {

    var localctx = new BreakStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, ECMAScriptParser.RULE_breakStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 274;
        this.match(ECMAScriptParser.Break);
        this.state = 277;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,18,this._ctx);
        if(la_===1) {
            this.state = 275;
            if (!( !this.here(ECMAScriptParser.LineTerminator))) {
                throw new antlr4.error.FailedPredicateException(this, "!this.here(ECMAScriptParser.LineTerminator)");
            }
            this.state = 276;
            this.match(ECMAScriptParser.Identifier);

        }
        this.state = 279;
        this.eos();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ReturnStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_returnStatement;
    return this;
}

ReturnStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ReturnStatementContext.prototype.constructor = ReturnStatementContext;

ReturnStatementContext.prototype.Return = function() {
    return this.getToken(ECMAScriptParser.Return, 0);
};

ReturnStatementContext.prototype.eos = function() {
    return this.getTypedRuleContext(EosContext,0);
};

ReturnStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

ReturnStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterReturnStatement(this);
	}
};

ReturnStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitReturnStatement(this);
	}
};




ECMAScriptParser.ReturnStatementContext = ReturnStatementContext;

ECMAScriptParser.prototype.returnStatement = function() {

    var localctx = new ReturnStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, ECMAScriptParser.RULE_returnStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 281;
        this.match(ECMAScriptParser.Return);
        this.state = 284;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,19,this._ctx);
        if(la_===1) {
            this.state = 282;
            if (!( !this.here(ECMAScriptParser.LineTerminator))) {
                throw new antlr4.error.FailedPredicateException(this, "!this.here(ECMAScriptParser.LineTerminator)");
            }
            this.state = 283;
            this.expressionSequence();

        }
        this.state = 286;
        this.eos();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function WithStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_withStatement;
    return this;
}

WithStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
WithStatementContext.prototype.constructor = WithStatementContext;

WithStatementContext.prototype.With = function() {
    return this.getToken(ECMAScriptParser.With, 0);
};

WithStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

WithStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

WithStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterWithStatement(this);
	}
};

WithStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitWithStatement(this);
	}
};




ECMAScriptParser.WithStatementContext = WithStatementContext;

ECMAScriptParser.prototype.withStatement = function() {

    var localctx = new WithStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, ECMAScriptParser.RULE_withStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 288;
        this.match(ECMAScriptParser.With);
        this.state = 289;
        this.match(ECMAScriptParser.OpenParen);
        this.state = 290;
        this.expressionSequence();
        this.state = 291;
        this.match(ECMAScriptParser.CloseParen);
        this.state = 292;
        this.statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SwitchStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_switchStatement;
    return this;
}

SwitchStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SwitchStatementContext.prototype.constructor = SwitchStatementContext;

SwitchStatementContext.prototype.Switch = function() {
    return this.getToken(ECMAScriptParser.Switch, 0);
};

SwitchStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

SwitchStatementContext.prototype.caseBlock = function() {
    return this.getTypedRuleContext(CaseBlockContext,0);
};

SwitchStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterSwitchStatement(this);
	}
};

SwitchStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitSwitchStatement(this);
	}
};




ECMAScriptParser.SwitchStatementContext = SwitchStatementContext;

ECMAScriptParser.prototype.switchStatement = function() {

    var localctx = new SwitchStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, ECMAScriptParser.RULE_switchStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 294;
        this.match(ECMAScriptParser.Switch);
        this.state = 295;
        this.match(ECMAScriptParser.OpenParen);
        this.state = 296;
        this.expressionSequence();
        this.state = 297;
        this.match(ECMAScriptParser.CloseParen);
        this.state = 298;
        this.caseBlock();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CaseBlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_caseBlock;
    return this;
}

CaseBlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CaseBlockContext.prototype.constructor = CaseBlockContext;

CaseBlockContext.prototype.caseClauses = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CaseClausesContext);
    } else {
        return this.getTypedRuleContext(CaseClausesContext,i);
    }
};

CaseBlockContext.prototype.defaultClause = function() {
    return this.getTypedRuleContext(DefaultClauseContext,0);
};

CaseBlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterCaseBlock(this);
	}
};

CaseBlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitCaseBlock(this);
	}
};




ECMAScriptParser.CaseBlockContext = CaseBlockContext;

ECMAScriptParser.prototype.caseBlock = function() {

    var localctx = new CaseBlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, ECMAScriptParser.RULE_caseBlock);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 300;
        this.match(ECMAScriptParser.OpenBrace);
        this.state = 302;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===ECMAScriptParser.Case) {
            this.state = 301;
            this.caseClauses();
        }

        this.state = 308;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===ECMAScriptParser.Default) {
            this.state = 304;
            this.defaultClause();
            this.state = 306;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===ECMAScriptParser.Case) {
                this.state = 305;
                this.caseClauses();
            }

        }

        this.state = 310;
        this.match(ECMAScriptParser.CloseBrace);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CaseClausesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_caseClauses;
    return this;
}

CaseClausesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CaseClausesContext.prototype.constructor = CaseClausesContext;

CaseClausesContext.prototype.caseClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CaseClauseContext);
    } else {
        return this.getTypedRuleContext(CaseClauseContext,i);
    }
};

CaseClausesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterCaseClauses(this);
	}
};

CaseClausesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitCaseClauses(this);
	}
};




ECMAScriptParser.CaseClausesContext = CaseClausesContext;

ECMAScriptParser.prototype.caseClauses = function() {

    var localctx = new CaseClausesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, ECMAScriptParser.RULE_caseClauses);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 313; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 312;
            this.caseClause();
            this.state = 315; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===ECMAScriptParser.Case);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CaseClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_caseClause;
    return this;
}

CaseClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CaseClauseContext.prototype.constructor = CaseClauseContext;

CaseClauseContext.prototype.Case = function() {
    return this.getToken(ECMAScriptParser.Case, 0);
};

CaseClauseContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

CaseClauseContext.prototype.statementList = function() {
    return this.getTypedRuleContext(StatementListContext,0);
};

CaseClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterCaseClause(this);
	}
};

CaseClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitCaseClause(this);
	}
};




ECMAScriptParser.CaseClauseContext = CaseClauseContext;

ECMAScriptParser.prototype.caseClause = function() {

    var localctx = new CaseClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, ECMAScriptParser.RULE_caseClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 317;
        this.match(ECMAScriptParser.Case);
        this.state = 318;
        this.expressionSequence();
        this.state = 319;
        this.match(ECMAScriptParser.Colon);
        this.state = 321;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
            this.state = 320;
            this.statementList();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DefaultClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_defaultClause;
    return this;
}

DefaultClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DefaultClauseContext.prototype.constructor = DefaultClauseContext;

DefaultClauseContext.prototype.Default = function() {
    return this.getToken(ECMAScriptParser.Default, 0);
};

DefaultClauseContext.prototype.statementList = function() {
    return this.getTypedRuleContext(StatementListContext,0);
};

DefaultClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterDefaultClause(this);
	}
};

DefaultClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitDefaultClause(this);
	}
};




ECMAScriptParser.DefaultClauseContext = DefaultClauseContext;

ECMAScriptParser.prototype.defaultClause = function() {

    var localctx = new DefaultClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, ECMAScriptParser.RULE_defaultClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 323;
        this.match(ECMAScriptParser.Default);
        this.state = 324;
        this.match(ECMAScriptParser.Colon);
        this.state = 326;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
            this.state = 325;
            this.statementList();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LabelledStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_labelledStatement;
    return this;
}

LabelledStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LabelledStatementContext.prototype.constructor = LabelledStatementContext;

LabelledStatementContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

LabelledStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

LabelledStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterLabelledStatement(this);
	}
};

LabelledStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitLabelledStatement(this);
	}
};




ECMAScriptParser.LabelledStatementContext = LabelledStatementContext;

ECMAScriptParser.prototype.labelledStatement = function() {

    var localctx = new LabelledStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, ECMAScriptParser.RULE_labelledStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 328;
        this.match(ECMAScriptParser.Identifier);
        this.state = 329;
        this.match(ECMAScriptParser.Colon);
        this.state = 330;
        this.statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ThrowStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_throwStatement;
    return this;
}

ThrowStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ThrowStatementContext.prototype.constructor = ThrowStatementContext;

ThrowStatementContext.prototype.Throw = function() {
    return this.getToken(ECMAScriptParser.Throw, 0);
};

ThrowStatementContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};

ThrowStatementContext.prototype.eos = function() {
    return this.getTypedRuleContext(EosContext,0);
};

ThrowStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterThrowStatement(this);
	}
};

ThrowStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitThrowStatement(this);
	}
};




ECMAScriptParser.ThrowStatementContext = ThrowStatementContext;

ECMAScriptParser.prototype.throwStatement = function() {

    var localctx = new ThrowStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, ECMAScriptParser.RULE_throwStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 332;
        this.match(ECMAScriptParser.Throw);
        this.state = 333;
        if (!( !this.here(ECMAScriptParser.LineTerminator))) {
            throw new antlr4.error.FailedPredicateException(this, "!this.here(ECMAScriptParser.LineTerminator)");
        }
        this.state = 334;
        this.expressionSequence();
        this.state = 335;
        this.eos();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TryStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_tryStatement;
    return this;
}

TryStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TryStatementContext.prototype.constructor = TryStatementContext;

TryStatementContext.prototype.Try = function() {
    return this.getToken(ECMAScriptParser.Try, 0);
};

TryStatementContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

TryStatementContext.prototype.catchProduction = function() {
    return this.getTypedRuleContext(CatchProductionContext,0);
};

TryStatementContext.prototype.finallyProduction = function() {
    return this.getTypedRuleContext(FinallyProductionContext,0);
};

TryStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterTryStatement(this);
	}
};

TryStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitTryStatement(this);
	}
};




ECMAScriptParser.TryStatementContext = TryStatementContext;

ECMAScriptParser.prototype.tryStatement = function() {

    var localctx = new TryStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, ECMAScriptParser.RULE_tryStatement);
    try {
        this.state = 350;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,26,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 337;
            this.match(ECMAScriptParser.Try);
            this.state = 338;
            this.block();
            this.state = 339;
            this.catchProduction();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 341;
            this.match(ECMAScriptParser.Try);
            this.state = 342;
            this.block();
            this.state = 343;
            this.finallyProduction();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 345;
            this.match(ECMAScriptParser.Try);
            this.state = 346;
            this.block();
            this.state = 347;
            this.catchProduction();
            this.state = 348;
            this.finallyProduction();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CatchProductionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_catchProduction;
    return this;
}

CatchProductionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CatchProductionContext.prototype.constructor = CatchProductionContext;

CatchProductionContext.prototype.Catch = function() {
    return this.getToken(ECMAScriptParser.Catch, 0);
};

CatchProductionContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

CatchProductionContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

CatchProductionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterCatchProduction(this);
	}
};

CatchProductionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitCatchProduction(this);
	}
};




ECMAScriptParser.CatchProductionContext = CatchProductionContext;

ECMAScriptParser.prototype.catchProduction = function() {

    var localctx = new CatchProductionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, ECMAScriptParser.RULE_catchProduction);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 352;
        this.match(ECMAScriptParser.Catch);
        this.state = 353;
        this.match(ECMAScriptParser.OpenParen);
        this.state = 354;
        this.match(ECMAScriptParser.Identifier);
        this.state = 355;
        this.match(ECMAScriptParser.CloseParen);
        this.state = 356;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FinallyProductionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_finallyProduction;
    return this;
}

FinallyProductionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FinallyProductionContext.prototype.constructor = FinallyProductionContext;

FinallyProductionContext.prototype.Finally = function() {
    return this.getToken(ECMAScriptParser.Finally, 0);
};

FinallyProductionContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

FinallyProductionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterFinallyProduction(this);
	}
};

FinallyProductionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitFinallyProduction(this);
	}
};




ECMAScriptParser.FinallyProductionContext = FinallyProductionContext;

ECMAScriptParser.prototype.finallyProduction = function() {

    var localctx = new FinallyProductionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, ECMAScriptParser.RULE_finallyProduction);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 358;
        this.match(ECMAScriptParser.Finally);
        this.state = 359;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_functionDeclaration;
    return this;
}

FunctionDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionDeclarationContext.prototype.constructor = FunctionDeclarationContext;

FunctionDeclarationContext.prototype.Function = function() {
    return this.getToken(ECMAScriptParser.Function, 0);
};

FunctionDeclarationContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

FunctionDeclarationContext.prototype.functionBody = function() {
    return this.getTypedRuleContext(FunctionBodyContext,0);
};

FunctionDeclarationContext.prototype.formalParameterList = function() {
    return this.getTypedRuleContext(FormalParameterListContext,0);
};

FunctionDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterFunctionDeclaration(this);
	}
};

FunctionDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitFunctionDeclaration(this);
	}
};




ECMAScriptParser.FunctionDeclarationContext = FunctionDeclarationContext;

ECMAScriptParser.prototype.functionDeclaration = function() {

    var localctx = new FunctionDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, ECMAScriptParser.RULE_functionDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 361;
        this.match(ECMAScriptParser.Function);
        this.state = 362;
        this.match(ECMAScriptParser.Identifier);
        this.state = 363;
        this.match(ECMAScriptParser.OpenParen);
        this.state = 365;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===ECMAScriptParser.Identifier) {
            this.state = 364;
            this.formalParameterList();
        }

        this.state = 367;
        this.match(ECMAScriptParser.CloseParen);
        this.state = 368;
        this.match(ECMAScriptParser.OpenBrace);
        this.state = 369;
        this.functionBody();
        this.state = 370;
        this.match(ECMAScriptParser.CloseBrace);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FormalParameterListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_formalParameterList;
    return this;
}

FormalParameterListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FormalParameterListContext.prototype.constructor = FormalParameterListContext;

FormalParameterListContext.prototype.Identifier = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ECMAScriptParser.Identifier);
    } else {
        return this.getToken(ECMAScriptParser.Identifier, i);
    }
};


FormalParameterListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterFormalParameterList(this);
	}
};

FormalParameterListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitFormalParameterList(this);
	}
};




ECMAScriptParser.FormalParameterListContext = FormalParameterListContext;

ECMAScriptParser.prototype.formalParameterList = function() {

    var localctx = new FormalParameterListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, ECMAScriptParser.RULE_formalParameterList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 372;
        this.match(ECMAScriptParser.Identifier);
        this.state = 377;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ECMAScriptParser.Comma) {
            this.state = 373;
            this.match(ECMAScriptParser.Comma);
            this.state = 374;
            this.match(ECMAScriptParser.Identifier);
            this.state = 379;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_functionBody;
    return this;
}

FunctionBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionBodyContext.prototype.constructor = FunctionBodyContext;

FunctionBodyContext.prototype.sourceElements = function() {
    return this.getTypedRuleContext(SourceElementsContext,0);
};

FunctionBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterFunctionBody(this);
	}
};

FunctionBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitFunctionBody(this);
	}
};




ECMAScriptParser.FunctionBodyContext = FunctionBodyContext;

ECMAScriptParser.prototype.functionBody = function() {

    var localctx = new FunctionBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 68, ECMAScriptParser.RULE_functionBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 381;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.SemiColon) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Break - 52)) | (1 << (ECMAScriptParser.Do - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Var - 52)) | (1 << (ECMAScriptParser.Return - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Continue - 52)) | (1 << (ECMAScriptParser.For - 52)) | (1 << (ECMAScriptParser.Switch - 52)) | (1 << (ECMAScriptParser.While - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.With - 52)) | (1 << (ECMAScriptParser.If - 52)) | (1 << (ECMAScriptParser.Throw - 52)) | (1 << (ECMAScriptParser.Delete - 52)) | (1 << (ECMAScriptParser.Try - 52)) | (1 << (ECMAScriptParser.OwlGet - 52)) | (1 << (ECMAScriptParser.OwlPost - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
            this.state = 380;
            this.sourceElements();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArrayLiteralContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_arrayLiteral;
    return this;
}

ArrayLiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArrayLiteralContext.prototype.constructor = ArrayLiteralContext;

ArrayLiteralContext.prototype.elementList = function() {
    return this.getTypedRuleContext(ElementListContext,0);
};

ArrayLiteralContext.prototype.elision = function() {
    return this.getTypedRuleContext(ElisionContext,0);
};

ArrayLiteralContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterArrayLiteral(this);
	}
};

ArrayLiteralContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitArrayLiteral(this);
	}
};




ECMAScriptParser.ArrayLiteralContext = ArrayLiteralContext;

ECMAScriptParser.prototype.arrayLiteral = function() {

    var localctx = new ArrayLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, ECMAScriptParser.RULE_arrayLiteral);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 383;
        this.match(ECMAScriptParser.OpenBracket);
        this.state = 385;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,30,this._ctx);
        if(la_===1) {
            this.state = 384;
            this.elementList();

        }
        this.state = 388;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,31,this._ctx);
        if(la_===1) {
            this.state = 387;
            this.match(ECMAScriptParser.Comma);

        }
        this.state = 391;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===ECMAScriptParser.Comma) {
            this.state = 390;
            this.elision();
        }

        this.state = 393;
        this.match(ECMAScriptParser.CloseBracket);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElementListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_elementList;
    return this;
}

ElementListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElementListContext.prototype.constructor = ElementListContext;

ElementListContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};

ElementListContext.prototype.elision = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ElisionContext);
    } else {
        return this.getTypedRuleContext(ElisionContext,i);
    }
};

ElementListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterElementList(this);
	}
};

ElementListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitElementList(this);
	}
};




ECMAScriptParser.ElementListContext = ElementListContext;

ECMAScriptParser.prototype.elementList = function() {

    var localctx = new ElementListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, ECMAScriptParser.RULE_elementList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 396;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===ECMAScriptParser.Comma) {
            this.state = 395;
            this.elision();
        }

        this.state = 398;
        this.singleExpression(0);
        this.state = 406;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,35,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 399;
                this.match(ECMAScriptParser.Comma);
                this.state = 401;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if(_la===ECMAScriptParser.Comma) {
                    this.state = 400;
                    this.elision();
                }

                this.state = 403;
                this.singleExpression(0); 
            }
            this.state = 408;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,35,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElisionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_elision;
    return this;
}

ElisionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElisionContext.prototype.constructor = ElisionContext;


ElisionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterElision(this);
	}
};

ElisionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitElision(this);
	}
};




ECMAScriptParser.ElisionContext = ElisionContext;

ECMAScriptParser.prototype.elision = function() {

    var localctx = new ElisionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 74, ECMAScriptParser.RULE_elision);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 410; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 409;
            this.match(ECMAScriptParser.Comma);
            this.state = 412; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===ECMAScriptParser.Comma);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ObjectLiteralContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_objectLiteral;
    return this;
}

ObjectLiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ObjectLiteralContext.prototype.constructor = ObjectLiteralContext;

ObjectLiteralContext.prototype.propertyNameAndValueList = function() {
    return this.getTypedRuleContext(PropertyNameAndValueListContext,0);
};

ObjectLiteralContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterObjectLiteral(this);
	}
};

ObjectLiteralContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitObjectLiteral(this);
	}
};




ECMAScriptParser.ObjectLiteralContext = ObjectLiteralContext;

ECMAScriptParser.prototype.objectLiteral = function() {

    var localctx = new ObjectLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, ECMAScriptParser.RULE_objectLiteral);
    var _la = 0; // Token type
    try {
        this.state = 423;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,38,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 414;
            this.match(ECMAScriptParser.OpenBrace);
            this.state = 415;
            this.match(ECMAScriptParser.CloseBrace);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 416;
            this.match(ECMAScriptParser.OpenBrace);
            this.state = 417;
            this.propertyNameAndValueList();
            this.state = 419;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===ECMAScriptParser.Comma) {
                this.state = 418;
                this.match(ECMAScriptParser.Comma);
            }

            this.state = 421;
            this.match(ECMAScriptParser.CloseBrace);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PropertyNameAndValueListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_propertyNameAndValueList;
    return this;
}

PropertyNameAndValueListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PropertyNameAndValueListContext.prototype.constructor = PropertyNameAndValueListContext;

PropertyNameAndValueListContext.prototype.propertyAssignment = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(PropertyAssignmentContext);
    } else {
        return this.getTypedRuleContext(PropertyAssignmentContext,i);
    }
};

PropertyNameAndValueListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPropertyNameAndValueList(this);
	}
};

PropertyNameAndValueListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPropertyNameAndValueList(this);
	}
};




ECMAScriptParser.PropertyNameAndValueListContext = PropertyNameAndValueListContext;

ECMAScriptParser.prototype.propertyNameAndValueList = function() {

    var localctx = new PropertyNameAndValueListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, ECMAScriptParser.RULE_propertyNameAndValueList);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 425;
        this.propertyAssignment();
        this.state = 430;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,39,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 426;
                this.match(ECMAScriptParser.Comma);
                this.state = 427;
                this.propertyAssignment(); 
            }
            this.state = 432;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,39,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PropertyAssignmentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_propertyAssignment;
    return this;
}

PropertyAssignmentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PropertyAssignmentContext.prototype.constructor = PropertyAssignmentContext;


 
PropertyAssignmentContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};


function PropertyExpressionAssignmentContext(parser, ctx) {
	PropertyAssignmentContext.call(this, parser);
    PropertyAssignmentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PropertyExpressionAssignmentContext.prototype = Object.create(PropertyAssignmentContext.prototype);
PropertyExpressionAssignmentContext.prototype.constructor = PropertyExpressionAssignmentContext;

ECMAScriptParser.PropertyExpressionAssignmentContext = PropertyExpressionAssignmentContext;

PropertyExpressionAssignmentContext.prototype.propertyName = function() {
    return this.getTypedRuleContext(PropertyNameContext,0);
};

PropertyExpressionAssignmentContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
PropertyExpressionAssignmentContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPropertyExpressionAssignment(this);
	}
};

PropertyExpressionAssignmentContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPropertyExpressionAssignment(this);
	}
};


function PropertySetterContext(parser, ctx) {
	PropertyAssignmentContext.call(this, parser);
    PropertyAssignmentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PropertySetterContext.prototype = Object.create(PropertyAssignmentContext.prototype);
PropertySetterContext.prototype.constructor = PropertySetterContext;

ECMAScriptParser.PropertySetterContext = PropertySetterContext;

PropertySetterContext.prototype.setter = function() {
    return this.getTypedRuleContext(SetterContext,0);
};

PropertySetterContext.prototype.propertySetParameterList = function() {
    return this.getTypedRuleContext(PropertySetParameterListContext,0);
};

PropertySetterContext.prototype.functionBody = function() {
    return this.getTypedRuleContext(FunctionBodyContext,0);
};
PropertySetterContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPropertySetter(this);
	}
};

PropertySetterContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPropertySetter(this);
	}
};


function PropertyGetterContext(parser, ctx) {
	PropertyAssignmentContext.call(this, parser);
    PropertyAssignmentContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PropertyGetterContext.prototype = Object.create(PropertyAssignmentContext.prototype);
PropertyGetterContext.prototype.constructor = PropertyGetterContext;

ECMAScriptParser.PropertyGetterContext = PropertyGetterContext;

PropertyGetterContext.prototype.getter = function() {
    return this.getTypedRuleContext(GetterContext,0);
};

PropertyGetterContext.prototype.functionBody = function() {
    return this.getTypedRuleContext(FunctionBodyContext,0);
};
PropertyGetterContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPropertyGetter(this);
	}
};

PropertyGetterContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPropertyGetter(this);
	}
};



ECMAScriptParser.PropertyAssignmentContext = PropertyAssignmentContext;

ECMAScriptParser.prototype.propertyAssignment = function() {

    var localctx = new PropertyAssignmentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 80, ECMAScriptParser.RULE_propertyAssignment);
    try {
        this.state = 452;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,40,this._ctx);
        switch(la_) {
        case 1:
            localctx = new PropertyExpressionAssignmentContext(this, localctx);
            this.enterOuterAlt(localctx, 1);
            this.state = 433;
            this.propertyName();
            this.state = 434;
            this.match(ECMAScriptParser.Colon);
            this.state = 435;
            this.singleExpression(0);
            break;

        case 2:
            localctx = new PropertyGetterContext(this, localctx);
            this.enterOuterAlt(localctx, 2);
            this.state = 437;
            this.getter();
            this.state = 438;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 439;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 440;
            this.match(ECMAScriptParser.OpenBrace);
            this.state = 441;
            this.functionBody();
            this.state = 442;
            this.match(ECMAScriptParser.CloseBrace);
            break;

        case 3:
            localctx = new PropertySetterContext(this, localctx);
            this.enterOuterAlt(localctx, 3);
            this.state = 444;
            this.setter();
            this.state = 445;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 446;
            this.propertySetParameterList();
            this.state = 447;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 448;
            this.match(ECMAScriptParser.OpenBrace);
            this.state = 449;
            this.functionBody();
            this.state = 450;
            this.match(ECMAScriptParser.CloseBrace);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PropertyNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_propertyName;
    return this;
}

PropertyNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PropertyNameContext.prototype.constructor = PropertyNameContext;

PropertyNameContext.prototype.identifierName = function() {
    return this.getTypedRuleContext(IdentifierNameContext,0);
};

PropertyNameContext.prototype.StringLiteral = function() {
    return this.getToken(ECMAScriptParser.StringLiteral, 0);
};

PropertyNameContext.prototype.numericLiteral = function() {
    return this.getTypedRuleContext(NumericLiteralContext,0);
};

PropertyNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPropertyName(this);
	}
};

PropertyNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPropertyName(this);
	}
};




ECMAScriptParser.PropertyNameContext = PropertyNameContext;

ECMAScriptParser.prototype.propertyName = function() {

    var localctx = new PropertyNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, ECMAScriptParser.RULE_propertyName);
    try {
        this.state = 457;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.NullLiteral:
        case ECMAScriptParser.BooleanLiteral:
        case ECMAScriptParser.Break:
        case ECMAScriptParser.Do:
        case ECMAScriptParser.Instanceof:
        case ECMAScriptParser.Typeof:
        case ECMAScriptParser.Case:
        case ECMAScriptParser.Else:
        case ECMAScriptParser.New:
        case ECMAScriptParser.Var:
        case ECMAScriptParser.Catch:
        case ECMAScriptParser.Finally:
        case ECMAScriptParser.Return:
        case ECMAScriptParser.Void:
        case ECMAScriptParser.Continue:
        case ECMAScriptParser.For:
        case ECMAScriptParser.Switch:
        case ECMAScriptParser.While:
        case ECMAScriptParser.Function:
        case ECMAScriptParser.This:
        case ECMAScriptParser.With:
        case ECMAScriptParser.Default:
        case ECMAScriptParser.If:
        case ECMAScriptParser.Throw:
        case ECMAScriptParser.Delete:
        case ECMAScriptParser.In:
        case ECMAScriptParser.Try:
        case ECMAScriptParser.Class:
        case ECMAScriptParser.Enum:
        case ECMAScriptParser.Extends:
        case ECMAScriptParser.Super:
        case ECMAScriptParser.Const:
        case ECMAScriptParser.Export:
        case ECMAScriptParser.Import:
        case ECMAScriptParser.Implements:
        case ECMAScriptParser.Let:
        case ECMAScriptParser.Private:
        case ECMAScriptParser.Public:
        case ECMAScriptParser.Interface:
        case ECMAScriptParser.Package:
        case ECMAScriptParser.Protected:
        case ECMAScriptParser.Static:
        case ECMAScriptParser.Yield:
        case ECMAScriptParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 454;
            this.identifierName();
            break;
        case ECMAScriptParser.StringLiteral:
            this.enterOuterAlt(localctx, 2);
            this.state = 455;
            this.match(ECMAScriptParser.StringLiteral);
            break;
        case ECMAScriptParser.DecimalLiteral:
        case ECMAScriptParser.HexIntegerLiteral:
        case ECMAScriptParser.OctalIntegerLiteral:
            this.enterOuterAlt(localctx, 3);
            this.state = 456;
            this.numericLiteral();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PropertySetParameterListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_propertySetParameterList;
    return this;
}

PropertySetParameterListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PropertySetParameterListContext.prototype.constructor = PropertySetParameterListContext;

PropertySetParameterListContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

PropertySetParameterListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPropertySetParameterList(this);
	}
};

PropertySetParameterListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPropertySetParameterList(this);
	}
};




ECMAScriptParser.PropertySetParameterListContext = PropertySetParameterListContext;

ECMAScriptParser.prototype.propertySetParameterList = function() {

    var localctx = new PropertySetParameterListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, ECMAScriptParser.RULE_propertySetParameterList);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 459;
        this.match(ECMAScriptParser.Identifier);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArgumentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_arguments;
    return this;
}

ArgumentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArgumentsContext.prototype.constructor = ArgumentsContext;

ArgumentsContext.prototype.argumentList = function() {
    return this.getTypedRuleContext(ArgumentListContext,0);
};

ArgumentsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterArguments(this);
	}
};

ArgumentsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitArguments(this);
	}
};




ECMAScriptParser.ArgumentsContext = ArgumentsContext;

ECMAScriptParser.prototype.arguments = function() {

    var localctx = new ArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, ECMAScriptParser.RULE_arguments);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 461;
        this.match(ECMAScriptParser.OpenParen);
        this.state = 463;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RegularExpressionLiteral) | (1 << ECMAScriptParser.OpenBracket) | (1 << ECMAScriptParser.OpenParen) | (1 << ECMAScriptParser.OpenBrace) | (1 << ECMAScriptParser.PlusPlus) | (1 << ECMAScriptParser.MinusMinus) | (1 << ECMAScriptParser.Plus) | (1 << ECMAScriptParser.Minus) | (1 << ECMAScriptParser.BitNot) | (1 << ECMAScriptParser.Not))) !== 0) || ((((_la - 52)) & ~0x1f) == 0 && ((1 << (_la - 52)) & ((1 << (ECMAScriptParser.NullLiteral - 52)) | (1 << (ECMAScriptParser.BooleanLiteral - 52)) | (1 << (ECMAScriptParser.DecimalLiteral - 52)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 52)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 52)) | (1 << (ECMAScriptParser.Typeof - 52)) | (1 << (ECMAScriptParser.New - 52)) | (1 << (ECMAScriptParser.Void - 52)) | (1 << (ECMAScriptParser.Function - 52)) | (1 << (ECMAScriptParser.This - 52)) | (1 << (ECMAScriptParser.Delete - 52)))) !== 0) || _la===ECMAScriptParser.Identifier || _la===ECMAScriptParser.StringLiteral) {
            this.state = 462;
            this.argumentList();
        }

        this.state = 465;
        this.match(ECMAScriptParser.CloseParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArgumentListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_argumentList;
    return this;
}

ArgumentListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArgumentListContext.prototype.constructor = ArgumentListContext;

ArgumentListContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};

ArgumentListContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterArgumentList(this);
	}
};

ArgumentListContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitArgumentList(this);
	}
};




ECMAScriptParser.ArgumentListContext = ArgumentListContext;

ECMAScriptParser.prototype.argumentList = function() {

    var localctx = new ArgumentListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, ECMAScriptParser.RULE_argumentList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 467;
        this.singleExpression(0);
        this.state = 472;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ECMAScriptParser.Comma) {
            this.state = 468;
            this.match(ECMAScriptParser.Comma);
            this.state = 469;
            this.singleExpression(0);
            this.state = 474;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionSequenceContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_expressionSequence;
    return this;
}

ExpressionSequenceContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionSequenceContext.prototype.constructor = ExpressionSequenceContext;

ExpressionSequenceContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};

ExpressionSequenceContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterExpressionSequence(this);
	}
};

ExpressionSequenceContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitExpressionSequence(this);
	}
};




ECMAScriptParser.ExpressionSequenceContext = ExpressionSequenceContext;

ECMAScriptParser.prototype.expressionSequence = function() {

    var localctx = new ExpressionSequenceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, ECMAScriptParser.RULE_expressionSequence);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 475;
        this.singleExpression(0);
        this.state = 480;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,44,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 476;
                this.match(ECMAScriptParser.Comma);
                this.state = 477;
                this.singleExpression(0); 
            }
            this.state = 482;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,44,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SingleExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_singleExpression;
    return this;
}

SingleExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SingleExpressionContext.prototype.constructor = SingleExpressionContext;


 
SingleExpressionContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};

function TernaryExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TernaryExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
TernaryExpressionContext.prototype.constructor = TernaryExpressionContext;

ECMAScriptParser.TernaryExpressionContext = TernaryExpressionContext;

TernaryExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
TernaryExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterTernaryExpression(this);
	}
};

TernaryExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitTernaryExpression(this);
	}
};


function LogicalAndExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

LogicalAndExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
LogicalAndExpressionContext.prototype.constructor = LogicalAndExpressionContext;

ECMAScriptParser.LogicalAndExpressionContext = LogicalAndExpressionContext;

LogicalAndExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
LogicalAndExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterLogicalAndExpression(this);
	}
};

LogicalAndExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitLogicalAndExpression(this);
	}
};


function PreIncrementExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PreIncrementExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
PreIncrementExpressionContext.prototype.constructor = PreIncrementExpressionContext;

ECMAScriptParser.PreIncrementExpressionContext = PreIncrementExpressionContext;

PreIncrementExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
PreIncrementExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPreIncrementExpression(this);
	}
};

PreIncrementExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPreIncrementExpression(this);
	}
};


function ObjectLiteralExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ObjectLiteralExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
ObjectLiteralExpressionContext.prototype.constructor = ObjectLiteralExpressionContext;

ECMAScriptParser.ObjectLiteralExpressionContext = ObjectLiteralExpressionContext;

ObjectLiteralExpressionContext.prototype.objectLiteral = function() {
    return this.getTypedRuleContext(ObjectLiteralContext,0);
};
ObjectLiteralExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterObjectLiteralExpression(this);
	}
};

ObjectLiteralExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitObjectLiteralExpression(this);
	}
};


function InExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

InExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
InExpressionContext.prototype.constructor = InExpressionContext;

ECMAScriptParser.InExpressionContext = InExpressionContext;

InExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};

InExpressionContext.prototype.In = function() {
    return this.getToken(ECMAScriptParser.In, 0);
};
InExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterInExpression(this);
	}
};

InExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitInExpression(this);
	}
};


function LogicalOrExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

LogicalOrExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
LogicalOrExpressionContext.prototype.constructor = LogicalOrExpressionContext;

ECMAScriptParser.LogicalOrExpressionContext = LogicalOrExpressionContext;

LogicalOrExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
LogicalOrExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterLogicalOrExpression(this);
	}
};

LogicalOrExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitLogicalOrExpression(this);
	}
};


function NotExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

NotExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
NotExpressionContext.prototype.constructor = NotExpressionContext;

ECMAScriptParser.NotExpressionContext = NotExpressionContext;

NotExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
NotExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterNotExpression(this);
	}
};

NotExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitNotExpression(this);
	}
};


function PreDecreaseExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PreDecreaseExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
PreDecreaseExpressionContext.prototype.constructor = PreDecreaseExpressionContext;

ECMAScriptParser.PreDecreaseExpressionContext = PreDecreaseExpressionContext;

PreDecreaseExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
PreDecreaseExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPreDecreaseExpression(this);
	}
};

PreDecreaseExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPreDecreaseExpression(this);
	}
};


function ArgumentsExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ArgumentsExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
ArgumentsExpressionContext.prototype.constructor = ArgumentsExpressionContext;

ECMAScriptParser.ArgumentsExpressionContext = ArgumentsExpressionContext;

ArgumentsExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

ArgumentsExpressionContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};
ArgumentsExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterArgumentsExpression(this);
	}
};

ArgumentsExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitArgumentsExpression(this);
	}
};


function ThisExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ThisExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
ThisExpressionContext.prototype.constructor = ThisExpressionContext;

ECMAScriptParser.ThisExpressionContext = ThisExpressionContext;

ThisExpressionContext.prototype.This = function() {
    return this.getToken(ECMAScriptParser.This, 0);
};
ThisExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterThisExpression(this);
	}
};

ThisExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitThisExpression(this);
	}
};


function FunctionExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FunctionExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
FunctionExpressionContext.prototype.constructor = FunctionExpressionContext;

ECMAScriptParser.FunctionExpressionContext = FunctionExpressionContext;

FunctionExpressionContext.prototype.Function = function() {
    return this.getToken(ECMAScriptParser.Function, 0);
};

FunctionExpressionContext.prototype.functionBody = function() {
    return this.getTypedRuleContext(FunctionBodyContext,0);
};

FunctionExpressionContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

FunctionExpressionContext.prototype.formalParameterList = function() {
    return this.getTypedRuleContext(FormalParameterListContext,0);
};
FunctionExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterFunctionExpression(this);
	}
};

FunctionExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitFunctionExpression(this);
	}
};


function UnaryMinusExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryMinusExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
UnaryMinusExpressionContext.prototype.constructor = UnaryMinusExpressionContext;

ECMAScriptParser.UnaryMinusExpressionContext = UnaryMinusExpressionContext;

UnaryMinusExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
UnaryMinusExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterUnaryMinusExpression(this);
	}
};

UnaryMinusExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitUnaryMinusExpression(this);
	}
};


function PostDecreaseExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PostDecreaseExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
PostDecreaseExpressionContext.prototype.constructor = PostDecreaseExpressionContext;

ECMAScriptParser.PostDecreaseExpressionContext = PostDecreaseExpressionContext;

PostDecreaseExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
PostDecreaseExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPostDecreaseExpression(this);
	}
};

PostDecreaseExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPostDecreaseExpression(this);
	}
};


function AssignmentExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AssignmentExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
AssignmentExpressionContext.prototype.constructor = AssignmentExpressionContext;

ECMAScriptParser.AssignmentExpressionContext = AssignmentExpressionContext;

AssignmentExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

AssignmentExpressionContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};
AssignmentExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterAssignmentExpression(this);
	}
};

AssignmentExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitAssignmentExpression(this);
	}
};


function TypeofExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TypeofExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
TypeofExpressionContext.prototype.constructor = TypeofExpressionContext;

ECMAScriptParser.TypeofExpressionContext = TypeofExpressionContext;

TypeofExpressionContext.prototype.Typeof = function() {
    return this.getToken(ECMAScriptParser.Typeof, 0);
};

TypeofExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
TypeofExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterTypeofExpression(this);
	}
};

TypeofExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitTypeofExpression(this);
	}
};


function InstanceofExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

InstanceofExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
InstanceofExpressionContext.prototype.constructor = InstanceofExpressionContext;

ECMAScriptParser.InstanceofExpressionContext = InstanceofExpressionContext;

InstanceofExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};

InstanceofExpressionContext.prototype.Instanceof = function() {
    return this.getToken(ECMAScriptParser.Instanceof, 0);
};
InstanceofExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterInstanceofExpression(this);
	}
};

InstanceofExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitInstanceofExpression(this);
	}
};


function UnaryPlusExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryPlusExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
UnaryPlusExpressionContext.prototype.constructor = UnaryPlusExpressionContext;

ECMAScriptParser.UnaryPlusExpressionContext = UnaryPlusExpressionContext;

UnaryPlusExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
UnaryPlusExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterUnaryPlusExpression(this);
	}
};

UnaryPlusExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitUnaryPlusExpression(this);
	}
};


function DeleteExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

DeleteExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
DeleteExpressionContext.prototype.constructor = DeleteExpressionContext;

ECMAScriptParser.DeleteExpressionContext = DeleteExpressionContext;

DeleteExpressionContext.prototype.Delete = function() {
    return this.getToken(ECMAScriptParser.Delete, 0);
};

DeleteExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
DeleteExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterDeleteExpression(this);
	}
};

DeleteExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitDeleteExpression(this);
	}
};


function EqualityExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

EqualityExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
EqualityExpressionContext.prototype.constructor = EqualityExpressionContext;

ECMAScriptParser.EqualityExpressionContext = EqualityExpressionContext;

EqualityExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
EqualityExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterEqualityExpression(this);
	}
};

EqualityExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitEqualityExpression(this);
	}
};


function BitXOrExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BitXOrExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
BitXOrExpressionContext.prototype.constructor = BitXOrExpressionContext;

ECMAScriptParser.BitXOrExpressionContext = BitXOrExpressionContext;

BitXOrExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
BitXOrExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBitXOrExpression(this);
	}
};

BitXOrExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBitXOrExpression(this);
	}
};


function MultiplicativeExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

MultiplicativeExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
MultiplicativeExpressionContext.prototype.constructor = MultiplicativeExpressionContext;

ECMAScriptParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;

MultiplicativeExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
MultiplicativeExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterMultiplicativeExpression(this);
	}
};

MultiplicativeExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitMultiplicativeExpression(this);
	}
};


function BitShiftExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BitShiftExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
BitShiftExpressionContext.prototype.constructor = BitShiftExpressionContext;

ECMAScriptParser.BitShiftExpressionContext = BitShiftExpressionContext;

BitShiftExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
BitShiftExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBitShiftExpression(this);
	}
};

BitShiftExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBitShiftExpression(this);
	}
};


function ParenthesizedExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ParenthesizedExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
ParenthesizedExpressionContext.prototype.constructor = ParenthesizedExpressionContext;

ECMAScriptParser.ParenthesizedExpressionContext = ParenthesizedExpressionContext;

ParenthesizedExpressionContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};
ParenthesizedExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterParenthesizedExpression(this);
	}
};

ParenthesizedExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitParenthesizedExpression(this);
	}
};


function AdditiveExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AdditiveExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
AdditiveExpressionContext.prototype.constructor = AdditiveExpressionContext;

ECMAScriptParser.AdditiveExpressionContext = AdditiveExpressionContext;

AdditiveExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
AdditiveExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterAdditiveExpression(this);
	}
};

AdditiveExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitAdditiveExpression(this);
	}
};


function RelationalExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

RelationalExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
RelationalExpressionContext.prototype.constructor = RelationalExpressionContext;

ECMAScriptParser.RelationalExpressionContext = RelationalExpressionContext;

RelationalExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
RelationalExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterRelationalExpression(this);
	}
};

RelationalExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitRelationalExpression(this);
	}
};


function PostIncrementExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

PostIncrementExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
PostIncrementExpressionContext.prototype.constructor = PostIncrementExpressionContext;

ECMAScriptParser.PostIncrementExpressionContext = PostIncrementExpressionContext;

PostIncrementExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
PostIncrementExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterPostIncrementExpression(this);
	}
};

PostIncrementExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitPostIncrementExpression(this);
	}
};


function BitNotExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BitNotExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
BitNotExpressionContext.prototype.constructor = BitNotExpressionContext;

ECMAScriptParser.BitNotExpressionContext = BitNotExpressionContext;

BitNotExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
BitNotExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBitNotExpression(this);
	}
};

BitNotExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBitNotExpression(this);
	}
};


function NewExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

NewExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
NewExpressionContext.prototype.constructor = NewExpressionContext;

ECMAScriptParser.NewExpressionContext = NewExpressionContext;

NewExpressionContext.prototype.New = function() {
    return this.getToken(ECMAScriptParser.New, 0);
};

NewExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

NewExpressionContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};
NewExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterNewExpression(this);
	}
};

NewExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitNewExpression(this);
	}
};


function LiteralExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

LiteralExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
LiteralExpressionContext.prototype.constructor = LiteralExpressionContext;

ECMAScriptParser.LiteralExpressionContext = LiteralExpressionContext;

LiteralExpressionContext.prototype.literal = function() {
    return this.getTypedRuleContext(LiteralContext,0);
};
LiteralExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterLiteralExpression(this);
	}
};

LiteralExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitLiteralExpression(this);
	}
};


function ArrayLiteralExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ArrayLiteralExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
ArrayLiteralExpressionContext.prototype.constructor = ArrayLiteralExpressionContext;

ECMAScriptParser.ArrayLiteralExpressionContext = ArrayLiteralExpressionContext;

ArrayLiteralExpressionContext.prototype.arrayLiteral = function() {
    return this.getTypedRuleContext(ArrayLiteralContext,0);
};
ArrayLiteralExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterArrayLiteralExpression(this);
	}
};

ArrayLiteralExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitArrayLiteralExpression(this);
	}
};


function MemberDotExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

MemberDotExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
MemberDotExpressionContext.prototype.constructor = MemberDotExpressionContext;

ECMAScriptParser.MemberDotExpressionContext = MemberDotExpressionContext;

MemberDotExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

MemberDotExpressionContext.prototype.identifierName = function() {
    return this.getTypedRuleContext(IdentifierNameContext,0);
};
MemberDotExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterMemberDotExpression(this);
	}
};

MemberDotExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitMemberDotExpression(this);
	}
};


function MemberIndexExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

MemberIndexExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
MemberIndexExpressionContext.prototype.constructor = MemberIndexExpressionContext;

ECMAScriptParser.MemberIndexExpressionContext = MemberIndexExpressionContext;

MemberIndexExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

MemberIndexExpressionContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};
MemberIndexExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterMemberIndexExpression(this);
	}
};

MemberIndexExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitMemberIndexExpression(this);
	}
};


function IdentifierExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

IdentifierExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
IdentifierExpressionContext.prototype.constructor = IdentifierExpressionContext;

ECMAScriptParser.IdentifierExpressionContext = IdentifierExpressionContext;

IdentifierExpressionContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};
IdentifierExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterIdentifierExpression(this);
	}
};

IdentifierExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitIdentifierExpression(this);
	}
};


function BitAndExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BitAndExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
BitAndExpressionContext.prototype.constructor = BitAndExpressionContext;

ECMAScriptParser.BitAndExpressionContext = BitAndExpressionContext;

BitAndExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
BitAndExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBitAndExpression(this);
	}
};

BitAndExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBitAndExpression(this);
	}
};


function BitOrExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BitOrExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
BitOrExpressionContext.prototype.constructor = BitOrExpressionContext;

ECMAScriptParser.BitOrExpressionContext = BitOrExpressionContext;

BitOrExpressionContext.prototype.singleExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SingleExpressionContext);
    } else {
        return this.getTypedRuleContext(SingleExpressionContext,i);
    }
};
BitOrExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterBitOrExpression(this);
	}
};

BitOrExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitBitOrExpression(this);
	}
};


function AssignmentOperatorExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

AssignmentOperatorExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
AssignmentOperatorExpressionContext.prototype.constructor = AssignmentOperatorExpressionContext;

ECMAScriptParser.AssignmentOperatorExpressionContext = AssignmentOperatorExpressionContext;

AssignmentOperatorExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};

AssignmentOperatorExpressionContext.prototype.assignmentOperator = function() {
    return this.getTypedRuleContext(AssignmentOperatorContext,0);
};

AssignmentOperatorExpressionContext.prototype.expressionSequence = function() {
    return this.getTypedRuleContext(ExpressionSequenceContext,0);
};
AssignmentOperatorExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterAssignmentOperatorExpression(this);
	}
};

AssignmentOperatorExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitAssignmentOperatorExpression(this);
	}
};


function VoidExpressionContext(parser, ctx) {
	SingleExpressionContext.call(this, parser);
    SingleExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

VoidExpressionContext.prototype = Object.create(SingleExpressionContext.prototype);
VoidExpressionContext.prototype.constructor = VoidExpressionContext;

ECMAScriptParser.VoidExpressionContext = VoidExpressionContext;

VoidExpressionContext.prototype.Void = function() {
    return this.getToken(ECMAScriptParser.Void, 0);
};

VoidExpressionContext.prototype.singleExpression = function() {
    return this.getTypedRuleContext(SingleExpressionContext,0);
};
VoidExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterVoidExpression(this);
	}
};

VoidExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitVoidExpression(this);
	}
};



ECMAScriptParser.prototype.singleExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new SingleExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 92;
    this.enterRecursionRule(localctx, 92, ECMAScriptParser.RULE_singleExpression, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 529;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.Function:
            localctx = new FunctionExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;

            this.state = 484;
            this.match(ECMAScriptParser.Function);
            this.state = 486;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===ECMAScriptParser.Identifier) {
                this.state = 485;
                this.match(ECMAScriptParser.Identifier);
            }

            this.state = 488;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 490;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if(_la===ECMAScriptParser.Identifier) {
                this.state = 489;
                this.formalParameterList();
            }

            this.state = 492;
            this.match(ECMAScriptParser.CloseParen);
            this.state = 493;
            this.match(ECMAScriptParser.OpenBrace);
            this.state = 494;
            this.functionBody();
            this.state = 495;
            this.match(ECMAScriptParser.CloseBrace);
            break;
        case ECMAScriptParser.New:
            localctx = new NewExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 497;
            this.match(ECMAScriptParser.New);
            this.state = 498;
            this.singleExpression(0);
            this.state = 500;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,47,this._ctx);
            if(la_===1) {
                this.state = 499;
                this.arguments();

            }
            break;
        case ECMAScriptParser.Delete:
            localctx = new DeleteExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 502;
            this.match(ECMAScriptParser.Delete);
            this.state = 503;
            this.singleExpression(30);
            break;
        case ECMAScriptParser.Void:
            localctx = new VoidExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 504;
            this.match(ECMAScriptParser.Void);
            this.state = 505;
            this.singleExpression(29);
            break;
        case ECMAScriptParser.Typeof:
            localctx = new TypeofExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 506;
            this.match(ECMAScriptParser.Typeof);
            this.state = 507;
            this.singleExpression(28);
            break;
        case ECMAScriptParser.PlusPlus:
            localctx = new PreIncrementExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 508;
            this.match(ECMAScriptParser.PlusPlus);
            this.state = 509;
            this.singleExpression(27);
            break;
        case ECMAScriptParser.MinusMinus:
            localctx = new PreDecreaseExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 510;
            this.match(ECMAScriptParser.MinusMinus);
            this.state = 511;
            this.singleExpression(26);
            break;
        case ECMAScriptParser.Plus:
            localctx = new UnaryPlusExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 512;
            this.match(ECMAScriptParser.Plus);
            this.state = 513;
            this.singleExpression(25);
            break;
        case ECMAScriptParser.Minus:
            localctx = new UnaryMinusExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 514;
            this.match(ECMAScriptParser.Minus);
            this.state = 515;
            this.singleExpression(24);
            break;
        case ECMAScriptParser.BitNot:
            localctx = new BitNotExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 516;
            this.match(ECMAScriptParser.BitNot);
            this.state = 517;
            this.singleExpression(23);
            break;
        case ECMAScriptParser.Not:
            localctx = new NotExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 518;
            this.match(ECMAScriptParser.Not);
            this.state = 519;
            this.singleExpression(22);
            break;
        case ECMAScriptParser.This:
            localctx = new ThisExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 520;
            this.match(ECMAScriptParser.This);
            break;
        case ECMAScriptParser.Identifier:
            localctx = new IdentifierExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 521;
            this.match(ECMAScriptParser.Identifier);
            break;
        case ECMAScriptParser.RegularExpressionLiteral:
        case ECMAScriptParser.NullLiteral:
        case ECMAScriptParser.BooleanLiteral:
        case ECMAScriptParser.DecimalLiteral:
        case ECMAScriptParser.HexIntegerLiteral:
        case ECMAScriptParser.OctalIntegerLiteral:
        case ECMAScriptParser.StringLiteral:
            localctx = new LiteralExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 522;
            this.literal();
            break;
        case ECMAScriptParser.OpenBracket:
            localctx = new ArrayLiteralExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 523;
            this.arrayLiteral();
            break;
        case ECMAScriptParser.OpenBrace:
            localctx = new ObjectLiteralExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 524;
            this.objectLiteral();
            break;
        case ECMAScriptParser.OpenParen:
            localctx = new ParenthesizedExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 525;
            this.match(ECMAScriptParser.OpenParen);
            this.state = 526;
            this.expressionSequence();
            this.state = 527;
            this.match(ECMAScriptParser.CloseParen);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 598;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,50,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 596;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,49,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new MultiplicativeExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 531;
                    if (!( this.precpred(this._ctx, 21))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 21)");
                    }
                    this.state = 532;
                    _la = this._input.LA(1);
                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.Multiply) | (1 << ECMAScriptParser.Divide) | (1 << ECMAScriptParser.Modulus))) !== 0))) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 533;
                    this.singleExpression(22);
                    break;

                case 2:
                    localctx = new AdditiveExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 534;
                    if (!( this.precpred(this._ctx, 20))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 20)");
                    }
                    this.state = 535;
                    _la = this._input.LA(1);
                    if(!(_la===ECMAScriptParser.Plus || _la===ECMAScriptParser.Minus)) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 536;
                    this.singleExpression(21);
                    break;

                case 3:
                    localctx = new BitShiftExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 537;
                    if (!( this.precpred(this._ctx, 19))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 19)");
                    }
                    this.state = 538;
                    _la = this._input.LA(1);
                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.RightShiftArithmetic) | (1 << ECMAScriptParser.LeftShiftArithmetic) | (1 << ECMAScriptParser.RightShiftLogical))) !== 0))) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 539;
                    this.singleExpression(20);
                    break;

                case 4:
                    localctx = new RelationalExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 540;
                    if (!( this.precpred(this._ctx, 18))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 18)");
                    }
                    this.state = 541;
                    _la = this._input.LA(1);
                    if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ECMAScriptParser.LessThan) | (1 << ECMAScriptParser.MoreThan) | (1 << ECMAScriptParser.LessThanEquals) | (1 << ECMAScriptParser.GreaterThanEquals))) !== 0))) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 542;
                    this.singleExpression(19);
                    break;

                case 5:
                    localctx = new InstanceofExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 543;
                    if (!( this.precpred(this._ctx, 17))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 17)");
                    }
                    this.state = 544;
                    this.match(ECMAScriptParser.Instanceof);
                    this.state = 545;
                    this.singleExpression(18);
                    break;

                case 6:
                    localctx = new InExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 546;
                    if (!( this.precpred(this._ctx, 16))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 16)");
                    }
                    this.state = 547;
                    this.match(ECMAScriptParser.In);
                    this.state = 548;
                    this.singleExpression(17);
                    break;

                case 7:
                    localctx = new EqualityExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 549;
                    if (!( this.precpred(this._ctx, 15))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 15)");
                    }
                    this.state = 550;
                    _la = this._input.LA(1);
                    if(!(((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ECMAScriptParser.Equals - 32)) | (1 << (ECMAScriptParser.NotEquals - 32)) | (1 << (ECMAScriptParser.IdentityEquals - 32)) | (1 << (ECMAScriptParser.IdentityNotEquals - 32)))) !== 0))) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 551;
                    this.singleExpression(16);
                    break;

                case 8:
                    localctx = new BitAndExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 552;
                    if (!( this.precpred(this._ctx, 14))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 14)");
                    }
                    this.state = 553;
                    this.match(ECMAScriptParser.BitAnd);
                    this.state = 554;
                    this.singleExpression(15);
                    break;

                case 9:
                    localctx = new BitXOrExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 555;
                    if (!( this.precpred(this._ctx, 13))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 13)");
                    }
                    this.state = 556;
                    this.match(ECMAScriptParser.BitXOr);
                    this.state = 557;
                    this.singleExpression(14);
                    break;

                case 10:
                    localctx = new BitOrExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 558;
                    if (!( this.precpred(this._ctx, 12))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 12)");
                    }
                    this.state = 559;
                    this.match(ECMAScriptParser.BitOr);
                    this.state = 560;
                    this.singleExpression(13);
                    break;

                case 11:
                    localctx = new LogicalAndExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 561;
                    if (!( this.precpred(this._ctx, 11))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 11)");
                    }
                    this.state = 562;
                    this.match(ECMAScriptParser.And);
                    this.state = 563;
                    this.singleExpression(12);
                    break;

                case 12:
                    localctx = new LogicalOrExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 564;
                    if (!( this.precpred(this._ctx, 10))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
                    }
                    this.state = 565;
                    this.match(ECMAScriptParser.Or);
                    this.state = 566;
                    this.singleExpression(11);
                    break;

                case 13:
                    localctx = new TernaryExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 567;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 568;
                    this.match(ECMAScriptParser.QuestionMark);
                    this.state = 569;
                    this.singleExpression(0);
                    this.state = 570;
                    this.match(ECMAScriptParser.Colon);
                    this.state = 571;
                    this.singleExpression(10);
                    break;

                case 14:
                    localctx = new MemberIndexExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 573;
                    if (!( this.precpred(this._ctx, 36))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 36)");
                    }
                    this.state = 574;
                    this.match(ECMAScriptParser.OpenBracket);
                    this.state = 575;
                    this.expressionSequence();
                    this.state = 576;
                    this.match(ECMAScriptParser.CloseBracket);
                    break;

                case 15:
                    localctx = new MemberDotExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 578;
                    if (!( this.precpred(this._ctx, 35))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 35)");
                    }
                    this.state = 579;
                    this.match(ECMAScriptParser.Dot);
                    this.state = 580;
                    this.identifierName();
                    break;

                case 16:
                    localctx = new ArgumentsExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 581;
                    if (!( this.precpred(this._ctx, 34))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 34)");
                    }
                    this.state = 582;
                    this.arguments();
                    break;

                case 17:
                    localctx = new PostIncrementExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 583;
                    if (!( this.precpred(this._ctx, 32))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 32)");
                    }
                    this.state = 584;
                    if (!( !this.here(ECMAScriptParser.LineTerminator))) {
                        throw new antlr4.error.FailedPredicateException(this, "!this.here(ECMAScriptParser.LineTerminator)");
                    }
                    this.state = 585;
                    this.match(ECMAScriptParser.PlusPlus);
                    break;

                case 18:
                    localctx = new PostDecreaseExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 586;
                    if (!( this.precpred(this._ctx, 31))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 31)");
                    }
                    this.state = 587;
                    if (!( !this.here(ECMAScriptParser.LineTerminator))) {
                        throw new antlr4.error.FailedPredicateException(this, "!this.here(ECMAScriptParser.LineTerminator)");
                    }
                    this.state = 588;
                    this.match(ECMAScriptParser.MinusMinus);
                    break;

                case 19:
                    localctx = new AssignmentExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 589;
                    if (!( this.precpred(this._ctx, 8))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                    }
                    this.state = 590;
                    this.match(ECMAScriptParser.Assign);
                    this.state = 591;
                    this.expressionSequence();
                    break;

                case 20:
                    localctx = new AssignmentOperatorExpressionContext(this, new SingleExpressionContext(this, _parentctx, _parentState));
                    this.pushNewRecursionContext(localctx, _startState, ECMAScriptParser.RULE_singleExpression);
                    this.state = 592;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 593;
                    this.assignmentOperator();
                    this.state = 594;
                    this.expressionSequence();
                    break;

                } 
            }
            this.state = 600;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,50,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function AssignmentOperatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_assignmentOperator;
    return this;
}

AssignmentOperatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AssignmentOperatorContext.prototype.constructor = AssignmentOperatorContext;


AssignmentOperatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterAssignmentOperator(this);
	}
};

AssignmentOperatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitAssignmentOperator(this);
	}
};




ECMAScriptParser.AssignmentOperatorContext = AssignmentOperatorContext;

ECMAScriptParser.prototype.assignmentOperator = function() {

    var localctx = new AssignmentOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, ECMAScriptParser.RULE_assignmentOperator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 601;
        _la = this._input.LA(1);
        if(!(((((_la - 41)) & ~0x1f) == 0 && ((1 << (_la - 41)) & ((1 << (ECMAScriptParser.MultiplyAssign - 41)) | (1 << (ECMAScriptParser.DivideAssign - 41)) | (1 << (ECMAScriptParser.ModulusAssign - 41)) | (1 << (ECMAScriptParser.PlusAssign - 41)) | (1 << (ECMAScriptParser.MinusAssign - 41)) | (1 << (ECMAScriptParser.LeftShiftArithmeticAssign - 41)) | (1 << (ECMAScriptParser.RightShiftArithmeticAssign - 41)) | (1 << (ECMAScriptParser.RightShiftLogicalAssign - 41)) | (1 << (ECMAScriptParser.BitAndAssign - 41)) | (1 << (ECMAScriptParser.BitXorAssign - 41)) | (1 << (ECMAScriptParser.BitOrAssign - 41)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LiteralContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_literal;
    return this;
}

LiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LiteralContext.prototype.constructor = LiteralContext;

LiteralContext.prototype.NullLiteral = function() {
    return this.getToken(ECMAScriptParser.NullLiteral, 0);
};

LiteralContext.prototype.BooleanLiteral = function() {
    return this.getToken(ECMAScriptParser.BooleanLiteral, 0);
};

LiteralContext.prototype.StringLiteral = function() {
    return this.getToken(ECMAScriptParser.StringLiteral, 0);
};

LiteralContext.prototype.RegularExpressionLiteral = function() {
    return this.getToken(ECMAScriptParser.RegularExpressionLiteral, 0);
};

LiteralContext.prototype.numericLiteral = function() {
    return this.getTypedRuleContext(NumericLiteralContext,0);
};

LiteralContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterLiteral(this);
	}
};

LiteralContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitLiteral(this);
	}
};




ECMAScriptParser.LiteralContext = LiteralContext;

ECMAScriptParser.prototype.literal = function() {

    var localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 96, ECMAScriptParser.RULE_literal);
    var _la = 0; // Token type
    try {
        this.state = 605;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.RegularExpressionLiteral:
        case ECMAScriptParser.NullLiteral:
        case ECMAScriptParser.BooleanLiteral:
        case ECMAScriptParser.StringLiteral:
            this.enterOuterAlt(localctx, 1);
            this.state = 603;
            _la = this._input.LA(1);
            if(!(_la===ECMAScriptParser.RegularExpressionLiteral || _la===ECMAScriptParser.NullLiteral || _la===ECMAScriptParser.BooleanLiteral || _la===ECMAScriptParser.StringLiteral)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            break;
        case ECMAScriptParser.DecimalLiteral:
        case ECMAScriptParser.HexIntegerLiteral:
        case ECMAScriptParser.OctalIntegerLiteral:
            this.enterOuterAlt(localctx, 2);
            this.state = 604;
            this.numericLiteral();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NumericLiteralContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_numericLiteral;
    return this;
}

NumericLiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NumericLiteralContext.prototype.constructor = NumericLiteralContext;

NumericLiteralContext.prototype.DecimalLiteral = function() {
    return this.getToken(ECMAScriptParser.DecimalLiteral, 0);
};

NumericLiteralContext.prototype.HexIntegerLiteral = function() {
    return this.getToken(ECMAScriptParser.HexIntegerLiteral, 0);
};

NumericLiteralContext.prototype.OctalIntegerLiteral = function() {
    return this.getToken(ECMAScriptParser.OctalIntegerLiteral, 0);
};

NumericLiteralContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterNumericLiteral(this);
	}
};

NumericLiteralContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitNumericLiteral(this);
	}
};




ECMAScriptParser.NumericLiteralContext = NumericLiteralContext;

ECMAScriptParser.prototype.numericLiteral = function() {

    var localctx = new NumericLiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, ECMAScriptParser.RULE_numericLiteral);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 607;
        _la = this._input.LA(1);
        if(!(((((_la - 54)) & ~0x1f) == 0 && ((1 << (_la - 54)) & ((1 << (ECMAScriptParser.DecimalLiteral - 54)) | (1 << (ECMAScriptParser.HexIntegerLiteral - 54)) | (1 << (ECMAScriptParser.OctalIntegerLiteral - 54)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IdentifierNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_identifierName;
    return this;
}

IdentifierNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IdentifierNameContext.prototype.constructor = IdentifierNameContext;

IdentifierNameContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

IdentifierNameContext.prototype.reservedWord = function() {
    return this.getTypedRuleContext(ReservedWordContext,0);
};

IdentifierNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterIdentifierName(this);
	}
};

IdentifierNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitIdentifierName(this);
	}
};




ECMAScriptParser.IdentifierNameContext = IdentifierNameContext;

ECMAScriptParser.prototype.identifierName = function() {

    var localctx = new IdentifierNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, ECMAScriptParser.RULE_identifierName);
    try {
        this.state = 611;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 609;
            this.match(ECMAScriptParser.Identifier);
            break;
        case ECMAScriptParser.NullLiteral:
        case ECMAScriptParser.BooleanLiteral:
        case ECMAScriptParser.Break:
        case ECMAScriptParser.Do:
        case ECMAScriptParser.Instanceof:
        case ECMAScriptParser.Typeof:
        case ECMAScriptParser.Case:
        case ECMAScriptParser.Else:
        case ECMAScriptParser.New:
        case ECMAScriptParser.Var:
        case ECMAScriptParser.Catch:
        case ECMAScriptParser.Finally:
        case ECMAScriptParser.Return:
        case ECMAScriptParser.Void:
        case ECMAScriptParser.Continue:
        case ECMAScriptParser.For:
        case ECMAScriptParser.Switch:
        case ECMAScriptParser.While:
        case ECMAScriptParser.Function:
        case ECMAScriptParser.This:
        case ECMAScriptParser.With:
        case ECMAScriptParser.Default:
        case ECMAScriptParser.If:
        case ECMAScriptParser.Throw:
        case ECMAScriptParser.Delete:
        case ECMAScriptParser.In:
        case ECMAScriptParser.Try:
        case ECMAScriptParser.Class:
        case ECMAScriptParser.Enum:
        case ECMAScriptParser.Extends:
        case ECMAScriptParser.Super:
        case ECMAScriptParser.Const:
        case ECMAScriptParser.Export:
        case ECMAScriptParser.Import:
        case ECMAScriptParser.Implements:
        case ECMAScriptParser.Let:
        case ECMAScriptParser.Private:
        case ECMAScriptParser.Public:
        case ECMAScriptParser.Interface:
        case ECMAScriptParser.Package:
        case ECMAScriptParser.Protected:
        case ECMAScriptParser.Static:
        case ECMAScriptParser.Yield:
            this.enterOuterAlt(localctx, 2);
            this.state = 610;
            this.reservedWord();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ReservedWordContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_reservedWord;
    return this;
}

ReservedWordContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ReservedWordContext.prototype.constructor = ReservedWordContext;

ReservedWordContext.prototype.keyword = function() {
    return this.getTypedRuleContext(KeywordContext,0);
};

ReservedWordContext.prototype.futureReservedWord = function() {
    return this.getTypedRuleContext(FutureReservedWordContext,0);
};

ReservedWordContext.prototype.NullLiteral = function() {
    return this.getToken(ECMAScriptParser.NullLiteral, 0);
};

ReservedWordContext.prototype.BooleanLiteral = function() {
    return this.getToken(ECMAScriptParser.BooleanLiteral, 0);
};

ReservedWordContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterReservedWord(this);
	}
};

ReservedWordContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitReservedWord(this);
	}
};




ECMAScriptParser.ReservedWordContext = ReservedWordContext;

ECMAScriptParser.prototype.reservedWord = function() {

    var localctx = new ReservedWordContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, ECMAScriptParser.RULE_reservedWord);
    var _la = 0; // Token type
    try {
        this.state = 616;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case ECMAScriptParser.Break:
        case ECMAScriptParser.Do:
        case ECMAScriptParser.Instanceof:
        case ECMAScriptParser.Typeof:
        case ECMAScriptParser.Case:
        case ECMAScriptParser.Else:
        case ECMAScriptParser.New:
        case ECMAScriptParser.Var:
        case ECMAScriptParser.Catch:
        case ECMAScriptParser.Finally:
        case ECMAScriptParser.Return:
        case ECMAScriptParser.Void:
        case ECMAScriptParser.Continue:
        case ECMAScriptParser.For:
        case ECMAScriptParser.Switch:
        case ECMAScriptParser.While:
        case ECMAScriptParser.Function:
        case ECMAScriptParser.This:
        case ECMAScriptParser.With:
        case ECMAScriptParser.Default:
        case ECMAScriptParser.If:
        case ECMAScriptParser.Throw:
        case ECMAScriptParser.Delete:
        case ECMAScriptParser.In:
        case ECMAScriptParser.Try:
            this.enterOuterAlt(localctx, 1);
            this.state = 613;
            this.keyword();
            break;
        case ECMAScriptParser.Class:
        case ECMAScriptParser.Enum:
        case ECMAScriptParser.Extends:
        case ECMAScriptParser.Super:
        case ECMAScriptParser.Const:
        case ECMAScriptParser.Export:
        case ECMAScriptParser.Import:
        case ECMAScriptParser.Implements:
        case ECMAScriptParser.Let:
        case ECMAScriptParser.Private:
        case ECMAScriptParser.Public:
        case ECMAScriptParser.Interface:
        case ECMAScriptParser.Package:
        case ECMAScriptParser.Protected:
        case ECMAScriptParser.Static:
        case ECMAScriptParser.Yield:
            this.enterOuterAlt(localctx, 2);
            this.state = 614;
            this.futureReservedWord();
            break;
        case ECMAScriptParser.NullLiteral:
        case ECMAScriptParser.BooleanLiteral:
            this.enterOuterAlt(localctx, 3);
            this.state = 615;
            _la = this._input.LA(1);
            if(!(_la===ECMAScriptParser.NullLiteral || _la===ECMAScriptParser.BooleanLiteral)) {
            this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function KeywordContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_keyword;
    return this;
}

KeywordContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
KeywordContext.prototype.constructor = KeywordContext;

KeywordContext.prototype.Break = function() {
    return this.getToken(ECMAScriptParser.Break, 0);
};

KeywordContext.prototype.Do = function() {
    return this.getToken(ECMAScriptParser.Do, 0);
};

KeywordContext.prototype.Instanceof = function() {
    return this.getToken(ECMAScriptParser.Instanceof, 0);
};

KeywordContext.prototype.Typeof = function() {
    return this.getToken(ECMAScriptParser.Typeof, 0);
};

KeywordContext.prototype.Case = function() {
    return this.getToken(ECMAScriptParser.Case, 0);
};

KeywordContext.prototype.Else = function() {
    return this.getToken(ECMAScriptParser.Else, 0);
};

KeywordContext.prototype.New = function() {
    return this.getToken(ECMAScriptParser.New, 0);
};

KeywordContext.prototype.Var = function() {
    return this.getToken(ECMAScriptParser.Var, 0);
};

KeywordContext.prototype.Catch = function() {
    return this.getToken(ECMAScriptParser.Catch, 0);
};

KeywordContext.prototype.Finally = function() {
    return this.getToken(ECMAScriptParser.Finally, 0);
};

KeywordContext.prototype.Return = function() {
    return this.getToken(ECMAScriptParser.Return, 0);
};

KeywordContext.prototype.Void = function() {
    return this.getToken(ECMAScriptParser.Void, 0);
};

KeywordContext.prototype.Continue = function() {
    return this.getToken(ECMAScriptParser.Continue, 0);
};

KeywordContext.prototype.For = function() {
    return this.getToken(ECMAScriptParser.For, 0);
};

KeywordContext.prototype.Switch = function() {
    return this.getToken(ECMAScriptParser.Switch, 0);
};

KeywordContext.prototype.While = function() {
    return this.getToken(ECMAScriptParser.While, 0);
};

KeywordContext.prototype.Function = function() {
    return this.getToken(ECMAScriptParser.Function, 0);
};

KeywordContext.prototype.This = function() {
    return this.getToken(ECMAScriptParser.This, 0);
};

KeywordContext.prototype.With = function() {
    return this.getToken(ECMAScriptParser.With, 0);
};

KeywordContext.prototype.Default = function() {
    return this.getToken(ECMAScriptParser.Default, 0);
};

KeywordContext.prototype.If = function() {
    return this.getToken(ECMAScriptParser.If, 0);
};

KeywordContext.prototype.Throw = function() {
    return this.getToken(ECMAScriptParser.Throw, 0);
};

KeywordContext.prototype.Delete = function() {
    return this.getToken(ECMAScriptParser.Delete, 0);
};

KeywordContext.prototype.In = function() {
    return this.getToken(ECMAScriptParser.In, 0);
};

KeywordContext.prototype.Try = function() {
    return this.getToken(ECMAScriptParser.Try, 0);
};

KeywordContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterKeyword(this);
	}
};

KeywordContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitKeyword(this);
	}
};




ECMAScriptParser.KeywordContext = KeywordContext;

ECMAScriptParser.prototype.keyword = function() {

    var localctx = new KeywordContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, ECMAScriptParser.RULE_keyword);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 618;
        _la = this._input.LA(1);
        if(!(((((_la - 57)) & ~0x1f) == 0 && ((1 << (_la - 57)) & ((1 << (ECMAScriptParser.Break - 57)) | (1 << (ECMAScriptParser.Do - 57)) | (1 << (ECMAScriptParser.Instanceof - 57)) | (1 << (ECMAScriptParser.Typeof - 57)) | (1 << (ECMAScriptParser.Case - 57)) | (1 << (ECMAScriptParser.Else - 57)) | (1 << (ECMAScriptParser.New - 57)) | (1 << (ECMAScriptParser.Var - 57)) | (1 << (ECMAScriptParser.Catch - 57)) | (1 << (ECMAScriptParser.Finally - 57)) | (1 << (ECMAScriptParser.Return - 57)) | (1 << (ECMAScriptParser.Void - 57)) | (1 << (ECMAScriptParser.Continue - 57)) | (1 << (ECMAScriptParser.For - 57)) | (1 << (ECMAScriptParser.Switch - 57)) | (1 << (ECMAScriptParser.While - 57)) | (1 << (ECMAScriptParser.Function - 57)) | (1 << (ECMAScriptParser.This - 57)) | (1 << (ECMAScriptParser.With - 57)) | (1 << (ECMAScriptParser.Default - 57)) | (1 << (ECMAScriptParser.If - 57)) | (1 << (ECMAScriptParser.Throw - 57)) | (1 << (ECMAScriptParser.Delete - 57)) | (1 << (ECMAScriptParser.In - 57)) | (1 << (ECMAScriptParser.Try - 57)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FutureReservedWordContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_futureReservedWord;
    return this;
}

FutureReservedWordContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FutureReservedWordContext.prototype.constructor = FutureReservedWordContext;

FutureReservedWordContext.prototype.Class = function() {
    return this.getToken(ECMAScriptParser.Class, 0);
};

FutureReservedWordContext.prototype.Enum = function() {
    return this.getToken(ECMAScriptParser.Enum, 0);
};

FutureReservedWordContext.prototype.Extends = function() {
    return this.getToken(ECMAScriptParser.Extends, 0);
};

FutureReservedWordContext.prototype.Super = function() {
    return this.getToken(ECMAScriptParser.Super, 0);
};

FutureReservedWordContext.prototype.Const = function() {
    return this.getToken(ECMAScriptParser.Const, 0);
};

FutureReservedWordContext.prototype.Export = function() {
    return this.getToken(ECMAScriptParser.Export, 0);
};

FutureReservedWordContext.prototype.Import = function() {
    return this.getToken(ECMAScriptParser.Import, 0);
};

FutureReservedWordContext.prototype.Implements = function() {
    return this.getToken(ECMAScriptParser.Implements, 0);
};

FutureReservedWordContext.prototype.Let = function() {
    return this.getToken(ECMAScriptParser.Let, 0);
};

FutureReservedWordContext.prototype.Private = function() {
    return this.getToken(ECMAScriptParser.Private, 0);
};

FutureReservedWordContext.prototype.Public = function() {
    return this.getToken(ECMAScriptParser.Public, 0);
};

FutureReservedWordContext.prototype.Interface = function() {
    return this.getToken(ECMAScriptParser.Interface, 0);
};

FutureReservedWordContext.prototype.Package = function() {
    return this.getToken(ECMAScriptParser.Package, 0);
};

FutureReservedWordContext.prototype.Protected = function() {
    return this.getToken(ECMAScriptParser.Protected, 0);
};

FutureReservedWordContext.prototype.Static = function() {
    return this.getToken(ECMAScriptParser.Static, 0);
};

FutureReservedWordContext.prototype.Yield = function() {
    return this.getToken(ECMAScriptParser.Yield, 0);
};

FutureReservedWordContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterFutureReservedWord(this);
	}
};

FutureReservedWordContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitFutureReservedWord(this);
	}
};




ECMAScriptParser.FutureReservedWordContext = FutureReservedWordContext;

ECMAScriptParser.prototype.futureReservedWord = function() {

    var localctx = new FutureReservedWordContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, ECMAScriptParser.RULE_futureReservedWord);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 620;
        _la = this._input.LA(1);
        if(!(((((_la - 84)) & ~0x1f) == 0 && ((1 << (_la - 84)) & ((1 << (ECMAScriptParser.Class - 84)) | (1 << (ECMAScriptParser.Enum - 84)) | (1 << (ECMAScriptParser.Extends - 84)) | (1 << (ECMAScriptParser.Super - 84)) | (1 << (ECMAScriptParser.Const - 84)) | (1 << (ECMAScriptParser.Export - 84)) | (1 << (ECMAScriptParser.Import - 84)) | (1 << (ECMAScriptParser.Implements - 84)) | (1 << (ECMAScriptParser.Let - 84)) | (1 << (ECMAScriptParser.Private - 84)) | (1 << (ECMAScriptParser.Public - 84)) | (1 << (ECMAScriptParser.Interface - 84)) | (1 << (ECMAScriptParser.Package - 84)) | (1 << (ECMAScriptParser.Protected - 84)) | (1 << (ECMAScriptParser.Static - 84)) | (1 << (ECMAScriptParser.Yield - 84)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GetterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_getter;
    return this;
}

GetterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GetterContext.prototype.constructor = GetterContext;

GetterContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

GetterContext.prototype.propertyName = function() {
    return this.getTypedRuleContext(PropertyNameContext,0);
};

GetterContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterGetter(this);
	}
};

GetterContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitGetter(this);
	}
};




ECMAScriptParser.GetterContext = GetterContext;

ECMAScriptParser.prototype.getter = function() {

    var localctx = new GetterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, ECMAScriptParser.RULE_getter);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 622;
        if (!( this._input.LT(1).text.startsWith("get"))) {
            throw new antlr4.error.FailedPredicateException(this, "this._input.LT(1).text.startsWith(\"get\")");
        }
        this.state = 623;
        this.match(ECMAScriptParser.Identifier);
        this.state = 624;
        this.propertyName();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SetterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_setter;
    return this;
}

SetterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SetterContext.prototype.constructor = SetterContext;

SetterContext.prototype.Identifier = function() {
    return this.getToken(ECMAScriptParser.Identifier, 0);
};

SetterContext.prototype.propertyName = function() {
    return this.getTypedRuleContext(PropertyNameContext,0);
};

SetterContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterSetter(this);
	}
};

SetterContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitSetter(this);
	}
};




ECMAScriptParser.SetterContext = SetterContext;

ECMAScriptParser.prototype.setter = function() {

    var localctx = new SetterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 110, ECMAScriptParser.RULE_setter);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 626;
        if (!( this._input.LT(1).text.startsWith("set"))) {
            throw new antlr4.error.FailedPredicateException(this, "this._input.LT(1).text.startsWith(\"set\")");
        }
        this.state = 627;
        this.match(ECMAScriptParser.Identifier);
        this.state = 628;
        this.propertyName();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EosContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_eos;
    return this;
}

EosContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EosContext.prototype.constructor = EosContext;

EosContext.prototype.SemiColon = function() {
    return this.getToken(ECMAScriptParser.SemiColon, 0);
};

EosContext.prototype.EOF = function() {
    return this.getToken(ECMAScriptParser.EOF, 0);
};

EosContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterEos(this);
	}
};

EosContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitEos(this);
	}
};




ECMAScriptParser.EosContext = EosContext;

ECMAScriptParser.prototype.eos = function() {

    var localctx = new EosContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, ECMAScriptParser.RULE_eos);
    try {
        this.state = 634;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,54,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 630;
            this.match(ECMAScriptParser.SemiColon);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 631;
            this.match(ECMAScriptParser.EOF);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 632;
            if (!( this.lineTerminatorAhead())) {
                throw new antlr4.error.FailedPredicateException(this, "this.lineTerminatorAhead()");
            }
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 633;
            if (!( this._input.LT(1).type == ECMAScriptParser.CloseBrace)) {
                throw new antlr4.error.FailedPredicateException(this, "this._input.LT(1).type == ECMAScriptParser.CloseBrace");
            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EofContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ECMAScriptParser.RULE_eof;
    return this;
}

EofContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EofContext.prototype.constructor = EofContext;

EofContext.prototype.EOF = function() {
    return this.getToken(ECMAScriptParser.EOF, 0);
};

EofContext.prototype.enterRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.enterEof(this);
	}
};

EofContext.prototype.exitRule = function(listener) {
    if(listener instanceof ECMAScriptListener ) {
        listener.exitEof(this);
	}
};




ECMAScriptParser.EofContext = EofContext;

ECMAScriptParser.prototype.eof = function() {

    var localctx = new EofContext(this, this._ctx, this.state);
    this.enterRule(localctx, 114, ECMAScriptParser.RULE_eof);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 636;
        this.match(ECMAScriptParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


ECMAScriptParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 18:
			return this.continueStatement_sempred(localctx, predIndex);
	case 19:
			return this.breakStatement_sempred(localctx, predIndex);
	case 20:
			return this.returnStatement_sempred(localctx, predIndex);
	case 28:
			return this.throwStatement_sempred(localctx, predIndex);
	case 46:
			return this.singleExpression_sempred(localctx, predIndex);
	case 54:
			return this.getter_sempred(localctx, predIndex);
	case 55:
			return this.setter_sempred(localctx, predIndex);
	case 56:
			return this.eos_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

ECMAScriptParser.prototype.continueStatement_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return !this.here(ECMAScriptParser.LineTerminator);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.breakStatement_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 1:
			return !this.here(ECMAScriptParser.LineTerminator);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.returnStatement_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 2:
			return !this.here(ECMAScriptParser.LineTerminator);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.throwStatement_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 3:
			return !this.here(ECMAScriptParser.LineTerminator);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.singleExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 4:
			return this.precpred(this._ctx, 21);
		case 5:
			return this.precpred(this._ctx, 20);
		case 6:
			return this.precpred(this._ctx, 19);
		case 7:
			return this.precpred(this._ctx, 18);
		case 8:
			return this.precpred(this._ctx, 17);
		case 9:
			return this.precpred(this._ctx, 16);
		case 10:
			return this.precpred(this._ctx, 15);
		case 11:
			return this.precpred(this._ctx, 14);
		case 12:
			return this.precpred(this._ctx, 13);
		case 13:
			return this.precpred(this._ctx, 12);
		case 14:
			return this.precpred(this._ctx, 11);
		case 15:
			return this.precpred(this._ctx, 10);
		case 16:
			return this.precpred(this._ctx, 9);
		case 17:
			return this.precpred(this._ctx, 36);
		case 18:
			return this.precpred(this._ctx, 35);
		case 19:
			return this.precpred(this._ctx, 34);
		case 20:
			return this.precpred(this._ctx, 32);
		case 21:
			return !this.here(ECMAScriptParser.LineTerminator);
		case 22:
			return this.precpred(this._ctx, 31);
		case 23:
			return !this.here(ECMAScriptParser.LineTerminator);
		case 24:
			return this.precpred(this._ctx, 8);
		case 25:
			return this.precpred(this._ctx, 7);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.getter_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 26:
			return this._input.LT(1).text.startsWith("get");
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.setter_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 27:
			return this._input.LT(1).text.startsWith("set");
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ECMAScriptParser.prototype.eos_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 28:
			return this.lineTerminatorAhead();
		case 29:
			return this._input.LT(1).type == ECMAScriptParser.CloseBrace;
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.ECMAScriptParser = ECMAScriptParser;
